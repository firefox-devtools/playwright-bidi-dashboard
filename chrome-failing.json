{
  "library/agent-expect.spec.ts": {
    "failing": [
      "expectVisible not found error",
      "expectVisible not visible error",
      "not expectVisible visible error",
      "expectChecked not checked error",
      "expectValue wrong value error",
      "expectAria wrong snapshot error",
      "expect timeout during run",
      "expect timeout during generate",
      "expectURL success",
      "expectURL wrong URL error",
      "expectURL with regex",
      "expectURL with regex error",
      "expectTitle success",
      "expectTitle wrong title error"
    ]
  },
  "library/agent-limits.spec.ts": {
    "failing": [
      "should respect total max tokens limit",
      "should respect call max tokens limit",
      "should respect max actions limit"
    ]
  },
  "library/agent-perform.spec.ts": {
    "failing": [
      "click a button",
      "retrieve a secret",
      "extract task",
      "expect value",
      "perform history",
      "perform run timeout",
      "invalid cache file throws error",
      "perform reports error"
    ]
  },
  "library/beforeunload.spec.ts": {
    "failing": [
      "should close browser with beforeunload page",
      "should close browsercontext with beforeunload page",
      "should be able to navigate away from page with beforeunload",
      "should close page with beforeunload listener",
      "should run beforeunload if asked for @smoke",
      "should access page after beforeunload",
      "should not stall on evaluate when dismissing beforeunload",
      "should not stall on click when dismissing beforeunload",
      "should support dismissing the dialog multiple times",
      "should support closing the page after a previous dismiss",
      "should support closing the page via a subsequent onbeforeunload dialog"
    ]
  },
  "library/browser.spec.ts": {
    "failing": [
      "should return browserType",
      "should create new page @smoke",
      "should throw upon second create new page",
      "version should work",
      "should dispatch page.on(close) upon browser.close and reject evaluate",
      "newContext should not leave a context upon failure"
    ]
  },
  "library/browsercontext-add-cookies.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with expires=-1",
      "should add cookies with empty value",
      "should set cookies with SameSite attribute and no secure attribute",
      "should roundtrip cookie",
      "should send cookie header",
      "should isolate cookies in browser contexts",
      "should isolate session cookies",
      "should isolate persistent cookies",
      "should isolate send cookie header",
      "should isolate cookies between launches",
      "should set multiple cookies",
      "should have |expires| set to |-1| for session cookies",
      "should set cookie with reasonable defaults",
      "should set a cookie with a path",
      "should not set a cookie with blank page URL",
      "should not set a cookie on a data URL page",
      "should default to setting secure cookie for HTTPS websites",
      "should be able to set unsecure cookie for HTTP website",
      "should set a cookie on a different domain",
      "should set cookies for a frame",
      "should allow unnamed cookies",
      "should set secure cookies on secure WebSocket"
    ]
  },
  "library/browsercontext-add-init-script.spec.ts": {
    "failing": [
      "should work with browser context scripts @smoke",
      "should work without navigation, after all bindings",
      "should work without navigation in popup",
      "should work with browser context scripts with a path",
      "should work with browser context scripts for already created pages",
      "init script should run only once in popup"
    ]
  },
  "library/browsercontext-base-url.spec.ts": {
    "failing": [
      "should construct a new URL when a baseURL in browser.newContext is passed to page.goto @smoke",
      "should construct a new URL when a baseURL in browser.newPage is passed to page.goto",
      "should construct a new URL when a baseURL in browserType.launchPersistentContext is passed to page.goto",
      "should construct the URLs correctly when a baseURL without a trailing slash in browser.newPage is passed to page.goto",
      "should construct the URLs correctly when a baseURL with a trailing slash in browser.newPage is passed to page.goto",
      "should not construct a new URL when valid URLs are passed",
      "should be able to match a URL relative to its given URL with urlMatcher",
      "should not construct a new URL with baseURL when a glob was used"
    ]
  },
  "library/browsercontext-basic.spec.ts": {
    "failing": [
      "should create new context @smoke",
      "should be able to click across browser contexts",
      "window.open should use parent tab context",
      "should isolate localStorage and cookies @smoke",
      "should propagate default viewport to the page",
      "should make a copy of default viewport",
      "should respect deviceScaleFactor",
      "should not allow deviceScaleFactor with null viewport",
      "should not allow isMobile with null viewport",
      "close() should work for empty context",
      "close() should abort waitForEvent",
      "close() should be callable twice",
      "should pass self to close event",
      "should not report frameless pages on error",
      "should return all of the pages",
      "should close all belonging pages once closing context",
      "should disable javascript",
      "should be able to navigate after disabling javascript",
      "should not hang on promises after disabling javascript",
      "setContent should work after disabling javascript",
      "should work with offline option",
      "fetch with keepalive should throw when offline",
      "should emulate navigator.onLine",
      "should emulate offline event",
      "should emulate media in popup",
      "should emulate media in cross-process iframe",
      "default user agent",
      "should create two pages in parallel in various contexts"
    ]
  },
  "library/browsercontext-clearcookies.spec.ts": {
    "failing": [
      "should clear cookies",
      "should isolate cookies when clearing",
      "should remove cookies by name",
      "should remove cookies by name regex",
      "should remove cookies by domain",
      "should remove cookies by path",
      "should remove cookies by name and domain"
    ]
  },
  "library/browsercontext-cookies-third-party.spec.ts": {
    "failing": [
      "third party non-partitioned cookies",
      "save/load third party non-partitioned cookies",
      "third party 'Partitioned;' cookies",
      "save/load third party 'Partitioned;' cookies",
      "add 'Partitioned;' cookie via API",
      "same origin third party 'Partitioned;' cookie with different origin intermediate iframe",
      "top level 'Partitioned;' cookie and same origin iframe",
      "should be able to send third party cookies via an iframe",
      "should(not) block third party cookies - persistent context",
      "should(not) block third party cookies - ephemeral context",
      "should not block third party SameSite=None cookies"
    ]
  },
  "library/browsercontext-cookies.spec.ts": {
    "failing": [
      "should return no cookies in pristine browser context",
      "should get a cookie @smoke",
      "should get a non-session cookie",
      "should properly report httpOnly cookie",
      "should properly report \"Strict\" sameSite cookie",
      "should properly report \"Lax\" sameSite cookie",
      "should get multiple cookies",
      "should get cookies from multiple urls",
      "should work with subdomain cookie",
      "should return cookies with empty value",
      "should return secure cookies based on HTTP(S) protocol",
      "should add cookies with an expiration",
      "should support requestStorageAccess",
      "should parse cookie with large Max-Age correctly",
      "iframe should inherit cookies from parent",
      "should allow adding cookies with >400 days expiration"
    ]
  },
  "library/browsercontext-credentials.spec.ts": {
    "failing": [
      "should fail without credentials",
      "should work with setHTTPCredentials",
      "should work with correct credentials @smoke",
      "should fail with wrong credentials",
      "should return resource body",
      "should work with correct credentials and matching origin",
      "should work with correct credentials and matching origin case insensitive",
      "should fail with correct credentials and mismatching scheme",
      "should fail with correct credentials and mismatching hostname",
      "should fail with correct credentials and mismatching port"
    ]
  },
  "library/browsercontext-csp.spec.ts": {
    "failing": [
      "should bypass CSP meta tag @smoke",
      "should bypass CSP header",
      "should bypass after cross-process navigation",
      "should bypass CSP in iframes as well"
    ]
  },
  "library/browsercontext-device.spec.ts": {
    "failing": [
      "device > should work @smoke",
      "device > should support clicking",
      "device > should scroll to click",
      "device > should scroll twice when emulated",
      "device > should reset scroll top after a navigation",
      "device > should scroll to a precise position with mobile scale",
      "device > should emulate viewport and screen size",
      "device > should emulate viewport without screen size"
    ]
  },
  "library/browsercontext-dsf.spec.ts": {
    "failing": [
      "should fetch lodpi assets @smoke",
      "should fetch hidpi assets"
    ]
  },
  "library/browsercontext-events.spec.ts": {
    "failing": [
      "console event should work @smoke",
      "console event should work with element handles",
      "console event should work in popup",
      "console event should work in popup 2",
      "console event should work in immediately closed popup",
      "dialog event should work @smoke",
      "dialog event should work in popup",
      "dialog event should work in popup 2",
      "dialog event should work in immediately closed popup",
      "dialog event should work with inline script tag",
      "weberror event should work"
    ]
  },
  "library/browsercontext-expose-function.spec.ts": {
    "failing": [
      "expose binding should work",
      "should work",
      "should throw for duplicate registrations",
      "should be callable from-inside addInitScript",
      "exposeBindingHandle should work",
      "should work with CSP"
    ]
  },
  "library/browsercontext-fetch-algorithms.spec.ts": {
    "failing": [
      "algorithms > gzip decompression > should support decompression",
      "algorithms > gzip decompression > should not fail if response content-length header is missing (gzip)",
      "algorithms > gzip decompression > should not fail with chunked responses (without Content-Length header)",
      "algorithms > gzip decompression > should not fail with an empty response without content-length header (Z_BUF_ERROR)",
      "algorithms > gzip decompression > should not fail with an empty response with content-length header (Z_BUF_ERROR)",
      "algorithms > deflate decompression > should support decompression",
      "algorithms > deflate decompression > should not fail if response content-length header is missing (deflate)",
      "algorithms > deflate decompression > should not fail with chunked responses (without Content-Length header)",
      "algorithms > deflate decompression > should not fail with an empty response without content-length header (Z_BUF_ERROR)",
      "algorithms > deflate decompression > should not fail with an empty response with content-length header (Z_BUF_ERROR)",
      "algorithms > br decompression > should support decompression",
      "algorithms > br decompression > should not fail if response content-length header is missing (br)",
      "algorithms > br decompression > should not fail with chunked responses (without Content-Length header)",
      "algorithms > br decompression > should not fail with an empty response without content-length header (Z_BUF_ERROR)",
      "algorithms > br decompression > should not fail with an empty response with content-length header (Z_BUF_ERROR)"
    ]
  },
  "library/browsercontext-fetch-happy-eyeballs.spec.ts": {
    "failing": [
      "get should work",
      "https post should work with ignoreHTTPSErrors option"
    ]
  },
  "library/browsercontext-fetch.spec.ts": {
    "failing": [
      "get should work @smoke",
      "fetch should work",
      "should throw on network error",
      "should throw on network error after redirect",
      "should throw on network error when sending body",
      "should throw on network error when sending body after redirect",
      "should add session cookies to request",
      "should filter cookies by domain",
      "fetch should support params passed as object",
      "fetch should support params passed as URLSearchParams",
      "fetch should support params passed as string",
      "fetch should support failOnStatusCode",
      "fetchshould support ignoreHTTPSErrors option",
      "delete should support params passed as object",
      "delete should support params passed as URLSearchParams",
      "delete should support params passed as string",
      "delete should support failOnStatusCode",
      "deleteshould support ignoreHTTPSErrors option",
      "get should support params passed as object",
      "get should support params passed as URLSearchParams",
      "get should support params passed as string",
      "get should support failOnStatusCode",
      "getshould support ignoreHTTPSErrors option",
      "head should support params passed as object",
      "head should support params passed as URLSearchParams",
      "head should support params passed as string",
      "head should support failOnStatusCode",
      "headshould support ignoreHTTPSErrors option",
      "patch should support params passed as object",
      "patch should support params passed as URLSearchParams",
      "patch should support params passed as string",
      "patch should support failOnStatusCode",
      "patchshould support ignoreHTTPSErrors option",
      "post should support params passed as object",
      "post should support params passed as URLSearchParams",
      "post should support params passed as string",
      "post should support failOnStatusCode",
      "postshould support ignoreHTTPSErrors option",
      "put should support params passed as object",
      "put should support params passed as URLSearchParams",
      "put should support params passed as string",
      "put should support failOnStatusCode",
      "putshould support ignoreHTTPSErrors option",
      "should not add context cookie if cookie header passed as a parameter",
      "should follow redirects",
      "should follow redirects correctly when Location header contains UTF-8 characters",
      "should add cookies from Set-Cookie header",
      "should preserve cookie order from Set-Cookie header",
      "should support cookie with empty value",
      "should not lose body while handling Set-Cookie header",
      "should remove cookie with negative max-age",
      "should remove cookie with expires far in the past",
      "should handle cookies on redirects",
      "should return raw headers",
      "should work with http credentials",
      "should work with setHTTPCredentials",
      "should return error with wrong credentials",
      "should support HTTPCredentials.send for newContext",
      "should support HTTPCredentials.send for browser.newPage",
      "delete should support post data",
      "get should support post data",
      "head should support post data",
      "patch should support post data",
      "post should support post data",
      "put should support post data",
      "should add default headers",
      "should send content-length",
      "should add default headers to redirects",
      "should allow to override default headers",
      "should propagate custom headers with redirects",
      "should propagate extra http headers with redirects",
      "should throw on invalid header value",
      "should throw on non-http(s) protocol",
      "should support https",
      "should inherit ignoreHTTPSErrors from context",
      "should resolve url relative to baseURL",
      "should support gzip compression",
      "should throw informative error on corrupted gzip body",
      "should support brotli compression",
      "should throw informative error on corrupted brotli body",
      "should support deflate compression",
      "should throw informative error on corrupted deflate body",
      "should support timeout option",
      "should support a timeout of 0",
      "should respect timeout after redirects",
      "should not hang on a brotli encoded Range request",
      "should dispose",
      "should dispose when context closes",
      "should override request parameters",
      "should support application/x-www-form-urlencoded",
      "should support application/x-www-form-urlencoded with param lists",
      "should encode to application/json by default",
      "should support multipart/form-data",
      "should support multipart/form-data with ReadStream values",
      "should support multipart/form-data and keep the order",
      "should support repeating names in multipart/form-data",
      "should serialize data to json regardless of content-type",
      "should throw nice error on unsupported data type",
      "context request should export same storage state as context",
      "should send secure cookie over http for localhost",
      "should accept bool and numeric params and filter out undefined",
      "should abort requests when browser context closes",
      "should work with connectOverCDP",
      "should support SameSite cookie attribute over https",
      "should set domain=localhost cookie",
      "fetch should not throw on long set-cookie value",
      "should support set-cookie with SameSite and without Secure attribute over HTTP",
      "should update host header on redirect",
      "should not work after dispose",
      "should not work after context dispose",
      "should retry on ECONNRESET"
    ]
  },
  "library/browsercontext-har.spec.ts": {
    "failing": [
      "should context.routeFromHAR, matching the method and following redirects",
      "should page.routeFromHAR, matching the method and following redirects",
      "fallback:continue should continue when not found in har",
      "by default should abort requests not found in har",
      "fallback:continue should continue requests on bad har",
      "should only handle requests matching url filter",
      "should only context.routeFromHAR requests matching url filter",
      "should only page.routeFromHAR requests matching url filter",
      "should apply overrides before routing from har",
      "should support regex filter",
      "newPage should fulfill from har, matching the method and following redirects",
      "should change document URL after redirected navigation",
      "should change document URL after redirected navigation on click",
      "should goBack to redirected navigation",
      "should goForward to redirected navigation",
      "should reload redirected navigation",
      "should fulfill from har with content in a file",
      "should round-trip har.zip",
      "should produce extracted zip",
      "should round-trip extracted har.zip",
      "should round-trip har with postData",
      "should record overridden requests to har",
      "should disambiguate by header",
      "should update har.zip for context",
      "should ignore boundary when matching multipart/form-data body",
      "should update har.zip for page",
      "should update har.zip for page with different options",
      "should update extracted har.zip for page",
      "page.unrouteAll should stop page.routeFromHAR",
      "context.unrouteAll should stop context.routeFromHAR",
      "should ignore aborted requests"
    ]
  },
  "library/browsercontext-locale.spec.ts": {
    "failing": [
      "should affect accept-language header @smoke",
      "should affect navigator.language",
      "should format number",
      "should format date",
      "should format number in popups",
      "should affect navigator.language in popups",
      "should work for multiple pages sharing same process",
      "should be isolated between contexts",
      "should not change default locale in another context",
      "should format number in workers",
      "should affect Intl.DateTimeFormat().resolvedOptions().locale"
    ]
  },
  "library/browsercontext-network-event.spec.ts": {
    "failing": [
      "BrowserContext.Events.Request",
      "BrowserContext.Events.Response",
      "BrowserContext.Events.RequestFailed",
      "BrowserContext.Events.RequestFinished",
      "should fire events in proper order",
      "should not fire events for favicon or favicon redirects",
      "should reject response.finished if context closes"
    ]
  },
  "library/browsercontext-page-event.spec.ts": {
    "failing": [
      "should have url",
      "should have url after domcontentloaded",
      "should have about:blank url with domcontentloaded",
      "should have about:blank for empty url with domcontentloaded",
      "should report when a new page is created and closed",
      "should report initialized pages",
      "should not crash while redirecting of original request was missed",
      "should have an opener",
      "should fire page lifecycle events",
      "should work with Shift-clicking",
      "should work with Ctrl-clicking"
    ]
  },
  "library/browsercontext-pages.spec.ts": {
    "failing": [
      "should not be visible in context.pages",
      "page.context should return the correct instance",
      "frame.focus should work multiple times",
      "should click with disabled javascript",
      "should not hang with touch-enabled viewports",
      "should click the button with deviceScaleFactor set",
      "should click the button with offset with page scale",
      "should return bounding box with page scale",
      "should not leak listeners during navigation of 20 pages",
      "should keep selection in multiple pages"
    ]
  },
  "library/browsercontext-proxy.spec.ts": {
    "failing": [
      "should work when passing the proxy only on the context level",
      "should throw for bad server value",
      "should use proxy",
      "should send secure cookies to subdomain.localhost",
      "should set cookie for top-level domain",
      "should use ipv6 proxy",
      "should use proxy twice",
      "should use proxy for second page",
      "should use proxy for https urls",
      "should work with IP:PORT notion",
      "should throw for socks5 authentication",
      "should throw for socks4 authentication",
      "should authenticate",
      "should authenticate with empty password",
      "should isolate proxy credentials between contexts",
      "should exclude patterns",
      "should use socks proxy",
      "should use socks proxy in second page",
      "does launch without a port",
      "should isolate proxy credentials between contexts on navigation",
      "should proxy local network requests > by default > localhost",
      "should proxy local network requests > by default > loopback address",
      "should proxy local network requests > by default > link-local",
      "should proxy local network requests > with other bypasses > localhost",
      "should proxy local network requests > with other bypasses > loopback address",
      "should proxy local network requests > with other bypasses > link-local"
    ]
  },
  "library/browsercontext-reuse.spec.ts": {
    "failing": [
      "reuse launch > should re-add binding after reset",
      "reuse launch > should reset serviceworker",
      "reuse launch > should reset serviceworker that hangs in importScripts",
      "reuse launch > should not cache resources",
      "reuse launch > should ignore binding from beforeunload",
      "reuse launch > should reset mouse position",
      "reuse launch > should reset tracing",
      "reuse launch > should work with clock emulation",
      "reuse launch > should continue issuing events after closing the reused page",
      "reuse launch > should work with routeWebSocket",
      "reuse launch > should update viewport and media",
      "reuse connect > should re-add binding after reset",
      "reuse connect > should reset serviceworker",
      "reuse connect > should reset serviceworker that hangs in importScripts",
      "reuse connect > should not cache resources",
      "reuse connect > should ignore binding from beforeunload",
      "reuse connect > should reset mouse position",
      "reuse connect > should reset tracing",
      "reuse connect > should work with clock emulation",
      "reuse connect > should continue issuing events after closing the reused page",
      "reuse connect > should work with routeWebSocket",
      "reuse connect > should update viewport and media"
    ]
  },
  "library/browsercontext-route.spec.ts": {
    "failing": [
      "should intercept",
      "should unroute",
      "should yield to page.route",
      "should fall back to context.route",
      "should support Set-Cookie header",
      "should ignore secure Set-Cookie header for insecure requests",
      "should use Set-Cookie header in future requests",
      "should work with ignoreHTTPSErrors",
      "should support the times parameter with route matching",
      "should work if handler with times parameter was removed from another handler",
      "should support async handler w/ times",
      "should overwrite post body with empty string",
      "should chain fallback",
      "should chain fallback w/ dynamic URL",
      "should not chain fulfill",
      "should not chain abort",
      "should chain fallback into page",
      "should fall back async"
    ]
  },
  "library/browsercontext-service-worker-policy.spec.ts": {
    "failing": [
      "should allow service workers by default",
      "block > blocks service worker registration",
      "block > should not throw error on about:blank"
    ]
  },
  "library/browsercontext-set-extra-http-headers.spec.ts": {
    "failing": [
      "should override extra headers from browser context",
      "should throw for non-string header values"
    ]
  },
  "library/browsercontext-storage-state.spec.ts": {
    "failing": [
      "should capture local storage",
      "should set local storage",
      "should report good error if the url is not valid",
      "should round-trip through the file",
      "should capture cookies",
      "should not emit events about internal page",
      "should not restore localStorage twice",
      "should handle missing file",
      "should handle malformed file",
      "should serialize storageState with lone surrogates",
      "should work when service worker is intefering",
      "should set local storage in third-party context",
      "should roundtrip local storage in third-party context",
      "should support IndexedDB",
      "should support empty indexedDB"
    ]
  },
  "library/browsercontext-strict.spec.ts": {
    "failing": [
      "should not fail page.textContent in non-strict mode",
      "strict context mode > should fail page.textContent in strict mode",
      "strict context mode > should fail page.click in strict mode",
      "strict context mode > should opt out of strict mode"
    ]
  },
  "library/browsercontext-timezone-id.spec.ts": {
    "failing": [
      "should work @smoke",
      "should throw for invalid timezone IDs when creating pages",
      "should work for multiple pages sharing same process",
      "should not change default timezone in another context",
      "should affect Intl.DateTimeFormat().resolvedOptions().timeZone"
    ]
  },
  "library/browsercontext-user-agent.spec.ts": {
    "failing": [
      "should work",
      "should work for subframes",
      "should emulate device user-agent",
      "should make a copy of default options",
      "custom user agent for download",
      "should work for navigator.userAgentData and sec-ch-ua headers"
    ]
  },
  "library/browsercontext-viewport-mobile.spec.ts": {
    "failing": [
      "mobile viewport > should support mobile emulation",
      "mobile viewport > should support touch emulation",
      "mobile viewport > should be detectable",
      "mobile viewport > should detect touch when applying viewport with touches",
      "mobile viewport > should support landscape emulation",
      "mobile viewport > should support window.orientation emulation",
      "mobile viewport > should fire orientationchange event",
      "mobile viewport > default mobile viewports to 980 width",
      "mobile viewport > respect meta viewport tag",
      "mobile viewport > should emulate the hover media feature",
      "mobile viewport > mouse should work with mobile viewports and cross process navigations",
      "mobile viewport > should scroll when emulating a mobile viewport",
      "mobile viewport > should scroll mobile page with background-attachment: fixed",
      "mobile viewport > view scale should reset after navigation",
      "mobile viewport > should preserve window.orientation override after navigation"
    ]
  },
  "library/browsercontext-viewport.spec.ts": {
    "failing": [
      "should get the proper default viewport size",
      "should set the proper viewport size",
      "should return correct outerWidth and outerHeight",
      "should emulate device width",
      "should emulate device height",
      "should emulate availWidth and availHeight",
      "should not have touch by default",
      "should throw on tap if hasTouch is not enabled",
      "should support touch with null viewport",
      "should set both screen and viewport options",
      "should report null viewportSize when given null viewport",
      "should drag with high dpi",
      "WebKit Windows headed should have a minimal viewport",
      "should be able to get correct orientation angle on non-mobile devices",
      "should set window.screen.orientation.type for mobile devices"
    ]
  },
  "library/browsertype-basic.spec.ts": {
    "skipped": [
      "browserType.executablePath should work",
      "should throw when trying to connect with not-chromium"
    ]
  },
  "library/browsertype-connect.spec.ts": {
    "failing": [
      "launchServer > should connect over wss",
      "launchServer > should be able to reconnect to a browser",
      "launchServer > should be able to visit ipv6",
      "launchServer > should ignore page.pause when headed",
      "launchServer > should be able to visit ipv6 through localhost",
      "launchServer > should be able to connect two browsers at the same time",
      "launchServer > should support slowmo option",
      "launchServer > disconnected event should be emitted when browser is closed or server is closed",
      "launchServer > disconnected event should have browser as argument",
      "launchServer > should handle exceptions during connect",
      "launchServer > should set the browser connected state",
      "launchServer > should throw when used after isConnected returns false",
      "launchServer > should throw when calling waitForNavigation after disconnect",
      "launchServer > should reject navigation when browser closes",
      "launchServer > should reject waitForSelector when browser closes",
      "launchServer > should emit close events on pages and contexts",
      "launchServer > should terminate network waiters",
      "launchServer > should reject waitForEvent before browser.close finishes",
      "launchServer > should reject waitForEvent before browser.onDisconnect fires",
      "launchServer > should respect selectors",
      "launchServer > should not throw on close after disconnect",
      "launchServer > should saveAs videos from remote browser",
      "launchServer > should be able to connect 20 times to a single server without warnings",
      "launchServer > should save download",
      "launchServer > should error when saving download after deletion",
      "launchServer > should properly disconnect when connection closes from the client side",
      "launchServer > should be able to connect when the wsEndpoint is passed as an option",
      "launchServer > should save har",
      "launchServer > should filter launch options",
      "launchServer > should record trace with sources",
      "launchServer > should fulfill with global fetch result",
      "launchServer > should upload large file",
      "launchServer > setInputFiles should preserve lastModified timestamp",
      "launchServer > should connect over http",
      "run-server > should connect over wss",
      "run-server > should be able to reconnect to a browser",
      "run-server > should be able to visit ipv6",
      "run-server > should ignore page.pause when headed",
      "run-server > should be able to visit ipv6 through localhost",
      "run-server > should be able to connect two browsers at the same time",
      "run-server > should support slowmo option",
      "run-server > disconnected event should be emitted when browser is closed or server is closed",
      "run-server > disconnected event should have browser as argument",
      "run-server > should set the browser connected state",
      "run-server > should throw when used after isConnected returns false",
      "run-server > should throw when calling waitForNavigation after disconnect",
      "run-server > should reject navigation when browser closes",
      "run-server > should reject waitForSelector when browser closes",
      "run-server > should emit close events on pages and contexts",
      "run-server > should terminate network waiters",
      "run-server > should reject waitForEvent before browser.close finishes",
      "run-server > should reject waitForEvent before browser.onDisconnect fires",
      "run-server > should respect selectors",
      "run-server > should not throw on close after disconnect",
      "run-server > should saveAs videos from remote browser",
      "run-server > should be able to connect 20 times to a single server without warnings",
      "run-server > should save download",
      "run-server > should error when saving download after deletion",
      "run-server > should properly disconnect when connection closes from the client side",
      "run-server > should be able to connect when the wsEndpoint is passed as an option",
      "run-server > should save har",
      "run-server > should filter launch options",
      "run-server > should record trace with sources",
      "run-server > should fulfill with global fetch result",
      "run-server > should upload large file",
      "run-server > setInputFiles should preserve lastModified timestamp",
      "run-server > should connect over http",
      "run-server > socks proxy > should forward non-forwarded requests",
      "run-server > socks proxy > should proxy localhost requests @smoke",
      "run-server > socks proxy > should proxy ipv6 localhost requests @smoke",
      "run-server > socks proxy > should proxy requests from fetch api",
      "run-server > socks proxy > should proxy requests from fetch api over ipv6",
      "run-server > socks proxy > should proxy local.playwright requests",
      "run-server > socks proxy > should lead to the error page for forwarded requests when the connection is refused",
      "run-server > socks proxy > should proxy based on the pattern",
      "run-server > socks proxy > should check proxy pattern on the client",
      "launchServer only > should work with cluster",
      "launchServer only > should properly disconnect when connection closes from the server side",
      "launchServer only > should be able to reconnect to a browser 12 times without warnings",
      "launchServer only > cannot launch another browser"
    ],
    "skipped": [
      "launchServer > socks proxy > should forward non-forwarded requests",
      "launchServer > socks proxy > should proxy localhost requests @smoke",
      "launchServer > socks proxy > should proxy ipv6 localhost requests @smoke",
      "launchServer > socks proxy > should proxy requests from fetch api",
      "launchServer > socks proxy > should proxy requests from fetch api over ipv6",
      "launchServer > socks proxy > should proxy local.playwright requests",
      "launchServer > socks proxy > should lead to the error page for forwarded requests when the connection is refused",
      "launchServer > socks proxy > should proxy based on the pattern",
      "launchServer > socks proxy > should check proxy pattern on the client"
    ]
  },
  "library/browsertype-launch-selenium.spec.ts": {
    "skipped": [
      "selenium grid 3.141.59 standalone chromium",
      "selenium grid 3.141.59 hub + node chromium",
      "selenium grid 4.8.3 standalone chromium",
      "selenium grid 4.8.3 hub + node chromium",
      "selenium grid 4.8.3 standalone chromium broken driver",
      "selenium grid 3.141.59 standalone non-chromium",
      "selenium grid 3.141.59 standalone chromium through run-driver"
    ]
  },
  "library/browsertype-launch-server.spec.ts": {
    "failing": [
      "launch server > should work",
      "launch server > should work with host",
      "launch server > should work with port",
      "launch server > should work with wsPath",
      "launch server > should work when wsPath is missing leading slash",
      "launch server > should default to random wsPath",
      "launch server > should provide an error when ws endpoint is incorrect",
      "launch server > should fire \"close\" event during kill",
      "launch server > should return child_process instance",
      "launch server > should fire close event",
      "launch server > should log protocol"
    ]
  },
  "library/browsertype-launch.spec.ts": {
    "failing": [
      "should reject all promises when browser is closed",
      "should handle timeout",
      "should handle exception",
      "should report launch log",
      "should accept objects as options",
      "should fire close event for all contexts",
      "should be callable twice",
      "should allow await using"
    ]
  },
  "library/capabilities.spec.ts": {
    "failing": [
      "SharedArrayBuffer should work @smoke",
      "Web Assembly should work @smoke",
      "WebSocket should work @smoke",
      "should respect CSP @smoke",
      "should play video @smoke",
      "should play webm video @smoke",
      "should play audio @smoke",
      "should support webgl @smoke",
      "should support webgl 2 @smoke",
      "should not crash on page with mp4 @smoke",
      "should not crash on showDirectoryPicker",
      "should not crash on storage.getDirectory()",
      "navigator.clipboard should be present",
      "should set CloseEvent.wasClean to false when the server terminates a WebSocket connection",
      "serviceWorker should intercept document request",
      "webkit should define window.safari",
      "make sure that XMLHttpRequest upload events are emitted correctly",
      "loading in HTMLImageElement.prototype",
      "window.GestureEvent in WebKit",
      "requestFullscreen",
      "should send no Content-Length header for GET requests with a Content-Type",
      "Intl.ListFormat should work",
      "service worker should cover the iframe",
      "service worker should register in an iframe",
      "should be able to render avif images",
      "should not crash when clicking a label with a <input type=\"file\"/>",
      "should not crash when clicking a color input",
      "should not auto play audio",
      "should not crash on feature detection for PublicKeyCredential"
    ]
  },
  "library/channels.spec.ts": {
    "failing": [
      "should scope context handles",
      "should scope CDPSession handles",
      "should scope browser handles",
      "should not generate dispatchers for subresources w/o listeners",
      "should work with the domain module",
      "exposeFunction should not leak"
    ]
  },
  "library/chromium/bfcache.spec.ts": {
    "failing": [
      "bindings should work after restoring from bfcache"
    ]
  },
  "library/chromium/chromium.spec.ts": {
    "failing": [
      "should create a worker from a service worker",
      "should create a worker from service worker with noop routing",
      "should emit new service worker on update",
      "serviceWorkers() should return current workers",
      "should not create a worker from a shared worker",
      "should emit console messages from service worker",
      "should capture console.log from ServiceWorker start",
      "Page.route should work with intervention headers",
      "should close service worker together with the context",
      "should pass args with spaces",
      "should throw when connecting twice to an already running persistent context (--remote-debugging-port)",
      "should throw when connecting twice to an already running persistent context (--remote-debugging-pipe)",
      "http credentials > httpCredentials",
      "serviceWorker(), and fromServiceWorker() work",
      "should intercept service worker requests (main and within)",
      "should report failure (due to content-type) of main service worker request",
      "should report failure (due to redirect) of main service worker request",
      "should intercept service worker importScripts",
      "should report intercepted service worker requests in HAR",
      "should intercept only serviceworker request, not page",
      "should produce network events, routing, and annotations for Service Worker",
      "should produce network events, routing, and annotations for Service Worker (advanced)",
      "should intercept service worker update requests",
      "setOffline",
      "setExtraHTTPHeaders",
      "PLAYWRIGHT_DISABLE_SERVICE_WORKER_NETWORK"
    ]
  },
  "library/chromium/connect-over-cdp.spec.ts": {
    "failing": [
      "should connect to an existing cdp session",
      "should use logger in default context",
      "should cleanup artifacts dir after connectOverCDP disconnects due to ws close",
      "should connectOverCDP and manage downloads in default context",
      "should connect to an existing cdp session twice",
      "should connect to existing page with iframe and navigate",
      "should connect to existing service workers",
      "should connect over a ws endpoint",
      "should report all pages in an existing browser",
      "should connect via https",
      "should return valid browser from context.browser()",
      "should connect to an existing cdp session when passed as a first argument",
      "should use proxy with connectOverCDP",
      "should be able to connect via localhost",
      "should allow tracing over cdp session",
      "setInputFiles should preserve lastModified timestamp",
      "should not reuse utility worlds between two clients",
      "setInputFiles should use local path when isLocal is set"
    ],
    "skipped": [
      "emulate media should not be affected by second connectOverCDP"
    ]
  },
  "library/chromium/css-coverage.spec.ts": {
    "failing": [
      "should work",
      "should report sourceURLs",
      "should report multiple stylesheets",
      "should report stylesheets that have no coverage",
      "should work with media queries",
      "should work with complicated usecases",
      "should ignore injected stylesheets",
      "should report stylesheets across navigations",
      "should NOT report scripts across navigations",
      "should work with a recently loaded stylesheet"
    ]
  },
  "library/chromium/disable-web-security.spec.ts": {
    "failing": [
      "test utility world in popup w/ --disable-web-security",
      "test init script w/ --disable-web-security"
    ]
  },
  "library/chromium/extensions.spec.ts": {
    "failing": [
      "MV3 > should give access to the service worker",
      "MV3 > should give access to the service worker when recording video",
      "MV3 > should support request/response events in the service worker",
      "MV3 > should report console messages from content script"
    ]
  },
  "library/chromium/js-coverage.spec.ts": {
    "failing": [
      "should work",
      "should report sourceURLs",
      "should ignore eval() scripts by default",
      "shouldn't ignore eval() scripts if reportAnonymousScripts is true",
      "should report multiple scripts",
      "should report scripts across navigations when disabled",
      "should NOT report scripts across navigations when enabled",
      "should not hang when there is a debugger statement"
    ]
  },
  "library/chromium/launcher.spec.ts": {
    "failing": [
      "should not throw with remote-debugging-port argument",
      "should not create pages automatically"
    ]
  },
  "library/chromium/oopif.spec.ts": {
    "failing": [
      "should report oopif frames",
      "should handle oopif detach",
      "should handle remote -> local -> remote transitions",
      "should get the proper viewport",
      "should expose function",
      "should emulate media",
      "should emulate offline",
      "should support context options",
      "should respect route",
      "should take screenshot",
      "should load oopif iframes with subresources and route",
      "should report main requests",
      "should support exposeFunction",
      "should support addInitScript",
      "should click a button when it overlays oopif",
      "should report google.com frame with headed",
      "ElementHandle.boundingBox() should work",
      "should click",
      "contentFrame should work",
      "should allow cdp sessions on oopifs",
      "should emit filechooser event for iframe",
      "should be able to click in iframe",
      "should not throw on exposeFunction when oopif detaches",
      "should intercept response body from oopif",
      "should allow to re-connect to OOPIFs with CDP when iframes were there already"
    ]
  },
  "library/chromium/session.spec.ts": {
    "failing": [
      "should work",
      "should send events",
      "should only accept a page or frame",
      "should enable and disable domains independently",
      "should be able to detach session",
      "should throw nice errors",
      "should work with main frame",
      "should throw if target is part of main",
      "should not break page.close()",
      "should detach when page closes",
      "should reject protocol calls when page closes",
      "should work with newBrowserCDPSession"
    ]
  },
  "library/chromium/tracing.spec.ts": {
    "failing": [
      "should output a trace",
      "should create directories as needed",
      "should run with custom categories if provided",
      "should throw if tracing on two pages",
      "should return a buffer",
      "should work without options",
      "should support a buffer without a path"
    ]
  },
  "library/client-certificates.spec.ts": {
    "failing": [
      "fetch > should work in the browser with request interception",
      "browser > validate input",
      "browser > should keep supporting http",
      "browser > should fail with no client certificates",
      "browser > should fail with self-signed client certificates",
      "browser > should pass with matching certificates",
      "browser > should pass with matching certificates when passing as content",
      "browser > should pass with matching certificates and when a http proxy is used",
      "browser > should pass with matching certificates and when a http proxy is used from env",
      "browser > should pass with matching certificates and when a http proxy is used from config but env is there",
      "browser > should pass with matching certificates and when a socks proxy is used",
      "browser > should not hang on tls errors during TLS 1.2 handshake",
      "browser > should pass with matching certificates in pfx format",
      "browser > should handle TLS renegotiation with client certificates",
      "browser > should pass with matching certificates in pfx format when passing as content",
      "browser > should fail with matching certificates in legacy pfx format",
      "browser > should throw a http error if the pfx passphrase is incorect",
      "browser > should pass with matching certificates on context APIRequestContext instance",
      "browser > should pass with matching certificates and trailing slash",
      "browser > should have ignoreHTTPSErrors=false by default",
      "browser > support http2",
      "browser > support http2 if the browser only supports http1.1",
      "browser > should return target connection errors when using http2",
      "browser > should handle rejected certificate in handshake with HTTP/2",
      "browser > persistentContext > should pass with matching certificates"
    ]
  },
  "library/debug-controller.spec.ts": {
    "failing": [
      "should pick element",
      "should report pages",
      "should reset for reuse",
      "should highlight all",
      "should record",
      "should record custom data-testid",
      "should reset routes before reuse",
      "should highlight inside iframe",
      "should highlight aria template"
    ]
  },
  "library/defaultbrowsercontext-1.spec.ts": {
    "failing": [
      "context.cookies() should work @smoke",
      "context.addCookies() should work",
      "context.clearCookies() should work",
      "should support viewport option",
      "should support deviceScaleFactor option",
      "should support userAgent option",
      "should support bypassCSP option",
      "should support javascriptEnabled option",
      "should support httpCredentials option",
      "should support offline option",
      "should support acceptDownloads option"
    ]
  },
  "library/defaultbrowsercontext-2.spec.ts": {
    "failing": [
      "should support hasTouch option",
      "should work in persistent context",
      "should support colorScheme option",
      "should support reducedMotion option",
      "should support forcedColors option",
      "should support contrast option",
      "should support timezoneId option",
      "should support locale option",
      "should support geolocation and permissions options",
      "should support ignoreHTTPSErrors option",
      "should support extraHTTPHeaders option",
      "should accept userDataDir",
      "should accept relative userDataDir",
      "should restore state from userDataDir",
      "should create userDataDir if it does not exist",
      "should have default URL when launching browser",
      "should have passed URL when launching with ignoreDefaultArgs: true",
      "should handle timeout",
      "should handle exception",
      "should fire close event for a persistent context",
      "coverage should work",
      "should respect selectors",
      "should connect to a browser with the default page",
      "should support har option",
      "user agent is up to date",
      "dialog.accept should work",
      "exposes browser"
    ]
  },
  "library/download.spec.ts": {
    "failing": [
      "should be able to download a PDF file",
      "should be able to download a inline PDF file via response interception",
      "should be able to download a inline PDF file via navigation",
      "should save to user-specified path",
      "should download even if there is no \"attachment\" value",
      "should convert navigation to a resource with unsupported mime type into download",
      "should download links with data url",
      "should download successfully when routing",
      "download event > should report download when navigation turns into download @smoke",
      "download event > should work with Cross-Origin-Opener-Policy",
      "download event > should report downloads with acceptDownloads: false",
      "download event > should report downloads with acceptDownloads: true",
      "download event > should report proper download url when download is from download attribute",
      "download event > should report downloads for download attribute",
      "download event > should save to user-specified path without updating original path",
      "download event > should save to two different paths with multiple saveAs calls",
      "download event > should save to overwritten filepath",
      "download event > should create subdirectories when saving to non-existent user-specified path",
      "download event > should error when saving with downloads disabled",
      "download event > should error when saving after deletion",
      "download event > should report non-navigation downloads",
      "download event > should report download path within page.on('download', ) handler for Files",
      "download event > should report download path within page.on('download', ) handler for Blobs",
      "download event > should report alt-click downloads",
      "download event > should report new window downloads",
      "download event > should delete file",
      "download event > should expose stream",
      "download event > should delete downloads on context destruction",
      "download event > should delete downloads on browser gone",
      "download event > should close the context without awaiting the failed download",
      "download event > should close the context without awaiting the download",
      "download event > should throw if browser dies",
      "download event > should download large binary.zip",
      "download event > should be able to cancel pending downloads",
      "download event > should not fail explicitly to cancel a download even if that is already finished",
      "download event > should report downloads with interception",
      "download event > should emit download event from nested iframes"
    ]
  },
  "library/downloads-path.spec.ts": {
    "failing": [
      "downloads path > should keep downloadsPath folder",
      "downloads path > should delete downloads when context closes",
      "downloads path > should report downloads in downloadsPath folder",
      "downloads path > should report downloads in downloadsPath folder with a relative path",
      "downloads path > should accept downloads in persistent context",
      "downloads path > should delete downloads when persistent context closes"
    ]
  },
  "library/emulation-focus.spec.ts": {
    "failing": [
      "should think that it is focused by default",
      "should think that all pages are focused @smoke",
      "should focus popups by default",
      "should provide target for keyboard events",
      "should not affect mouse event target page",
      "should change document.activeElement",
      "should not affect screenshots",
      "should change focused iframe",
      "should focus with more than one page/context",
      "should not fire blur events when interacting with more than one page/context",
      "should trigger hover state concurrently"
    ]
  },
  "library/favicon.spec.ts": {
    "failing": [
      "should load svg favicon with prefer-color-scheme"
    ]
  },
  "library/fetch-proxy.spec.ts": {
    "failing": [
      "context request should pick up proxy credentials",
      "should work with context level proxy",
      "should support proxy.bypass"
    ],
    "skipped": [
      "should send correct ALPN protocol to HTTPS proxy"
    ]
  },
  "library/geolocation.spec.ts": {
    "failing": [
      "should work @smoke",
      "should throw when invalid longitude",
      "should isolate contexts",
      "should throw with missing latitude",
      "should not modify passed default options object",
      "should throw with missing longitude in default options",
      "should use context options",
      "watchPosition should be notified",
      "should use context options for popup"
    ]
  },
  "library/har.spec.ts": {
    "failing": [
      "should have version and creator",
      "should have browser",
      "should have pages",
      "should have pages in persistent context",
      "should include request",
      "should include response",
      "should include redirectURL",
      "should include query params",
      "should include postData",
      "should include binary postData",
      "should include form params",
      "should include cookies",
      "should include set-cookies",
      "should skip invalid Expires",
      "should include set-cookies with comma",
      "should include secure set-cookies",
      "should record request overrides",
      "should include content @smoke",
      "should use attach mode for zip extension",
      "should omit content",
      "should omit content legacy",
      "should attach content",
      "should filter by glob",
      "should filter by regexp",
      "should include sizes",
      "should work with gzip compression",
      "should calculate time",
      "should return receive time",
      "should report the correct _transferSize with PNG files",
      "should have -1 _transferSize when its a failed request",
      "should record failed request headers",
      "should record failed request overrides",
      "should report the correct request body size",
      "should report the correct request body size when the bodySize is 0",
      "should report the correct response body size when the bodySize is 0",
      "should have popup requests",
      "should not contain internal pages",
      "should have connection details",
      "should have security details",
      "should have connection details for redirects",
      "should have connection details for failed requests",
      "should return server address directly from response",
      "should return security details directly from response",
      "should contain http2 for http2 requests",
      "should filter favicon and favicon redirects",
      "should have different hars for concurrent contexts",
      "should include API request",
      "should respect minimal mode for API Requests",
      "should include redirects from API request",
      "should not hang on resources served from cache",
      "should not hang on slow chunked response"
    ]
  },
  "library/headful.spec.ts": {
    "failing": [
      "should have default url when launching browser @smoke",
      "should close browser with beforeunload page",
      "should close browsercontext with pending beforeunload dialog",
      "should not crash when creating second context",
      "should click when viewport size is larger than screen",
      "should dispatch click events to oversized viewports",
      "should click background tab",
      "should close browser after context menu was triggered",
      "should(not) block third party cookies",
      "should not block third party SameSite=None cookies",
      "should not override viewport size when passed null",
      "Page.bringToFront should work",
      "should click in OOPIF",
      "should click bottom row w/ infobar in OOPIF",
      "headless and headful should use same default fonts",
      "should have the same hyphen rendering on headless and headed"
    ]
  },
  "library/hit-target.spec.ts": {
    "failing": [
      "should block all events when hit target is wrong",
      "should block click when mousedown fails",
      "should click when element detaches in mousedown",
      "should block all events when hit target is wrong and element detaches",
      "should not block programmatic events",
      "should click the button again after document.write",
      "should work with mui select",
      "should work with drag and drop that moves the element under cursor",
      "should work with block inside inline",
      "should work with block-block-block inside inline-inline",
      "should work with block inside inline in shadow dom",
      "should not click iframe overlaying the target",
      "should not click an element overlaying iframe with the target",
      "should click into frame inside closed shadow root",
      "should click an element inside closed shadow root",
      "should detect overlay from another shadow root",
      "should detect overlaid element in a transformed iframe",
      "should click in iframe with padding",
      "should click in iframe with padding 2",
      "should click in custom element"
    ]
  },
  "library/ignorehttpserrors.spec.ts": {
    "failing": [
      "should work @smoke",
      "should isolate contexts",
      "should isolated contexts that share network process",
      "should work with mixed content",
      "should work with WebSocket",
      "should fail with WebSocket if not ignored",
      "serviceWorker should intercept document request"
    ]
  },
  "library/launcher.spec.ts": {
    "failing": [
      "should kill browser process on timeout after close",
      "should throw a friendly error if its headed and there is no xserver on linux running"
    ]
  },
  "library/locator-dispatchevent-touch.spec.ts": {
    "failing": [
      "should support touch points in touch event arguments"
    ]
  },
  "library/locator-generator.spec.ts": {
    "failing": [
      "reverse engineer locators",
      "reverse engineer getByRole",
      "reverse engineer ignore-case locators",
      "reverse engineer ordered locators",
      "reverse engineer locators with regex",
      "reverse engineer hasText",
      "reverse engineer hasNotText",
      "reverse engineer visible",
      "reverse engineer has",
      "reverse engineer hasNot",
      "reverse engineer has + hasText",
      "reverse engineer frameLocator",
      "generate multiple locators",
      "should not oom in locator parser",
      " > reverse engineer internal:has-text locators"
    ]
  },
  "library/logger.spec.ts": {
    "failing": [
      "should log @smoke",
      "should log context-level"
    ]
  },
  "library/modernizr.spec.ts": {
    "failing": [
      "Safari Desktop",
      "Mobile Safari"
    ]
  },
  "library/multiclient.spec.ts": {
    "failing": [
      "should connect two clients",
      "should have separate default timeouts",
      "should receive viewport size changes",
      "should not allow parallel js coverage and cleanup upon disconnect",
      "should not allow parallel css coverage",
      "should unpause clock",
      "last emulateMedia wins",
      "should chain routes",
      "should remove exposed bindings upon disconnect",
      "should unroute websockets",
      "should remove init scripts upon disconnect",
      "should remove locator handlers upon disconnect",
      "should launch persistent",
      "should avoid side effects upon disconnect",
      "should stop tracing upon disconnect"
    ],
    "skipped": [
      "should chain routes with changed url"
    ]
  },
  "library/page-clock.frozen.spec.ts": {
    "failing": [
      "clock should be frozen",
      "clock should be realtime"
    ]
  },
  "library/page-clock.spec.ts": {
    "failing": [
      "correctly increments Date.now()/performance.now() during blocking execution",
      "runFor > triggers immediately without specified delay",
      "runFor > does not trigger without sufficient delay",
      "runFor > triggers after sufficient delay",
      "runFor > triggers simultaneous timers",
      "runFor > triggers multiple simultaneous timers",
      "runFor > waits after setTimeout was called",
      "runFor > triggers event when some throw",
      "runFor > creates updated Date while ticking",
      "runFor > passes 8 seconds",
      "runFor > passes 1 minute",
      "runFor > passes 2 hours, 34 minutes and 10 seconds",
      "runFor > throws for invalid format",
      "runFor > returns the current now value",
      "fastForward > ignores timers which wouldn't be run",
      "fastForward > pushes back execution time for skipped timers",
      "fastForward > supports string time arguments",
      "stubTimers > sets initial timestamp",
      "stubTimers > should throw for invalid date",
      "stubTimers > replaces global setTimeout",
      "stubTimers > global fake setTimeout should return id",
      "stubTimers > replaces global clearTimeout",
      "stubTimers > replaces global setInterval",
      "stubTimers > replaces global clearInterval",
      "stubTimers > replaces global performance.now",
      "stubTimers > fakes Date constructor",
      "stubTimers > replaces global performance.timeOrigin",
      "popup > should tick after popup",
      "popup > should tick before popup",
      "popup > should run time before popup",
      "popup > should not run time before popup on pause",
      "setFixedTime > does not fake methods",
      "setFixedTime > allows setting time multiple times",
      "setFixedTime > fixed time is not affected by clock manipulation",
      "setFixedTime > allows installing fake timers after settings time",
      "while running > should progress time",
      "while running > should runFor",
      "while running > should fastForward",
      "while running > should fastForwardTo",
      "while running > should pause",
      "while running > should pause and fastForward",
      "while running > should set system time on pause",
      "while on pause > fastForward should not run nested immediate",
      "while on pause > runFor should not run nested immediate",
      "while on pause > runFor should not run nested immediate from microtask",
      "Date.now > check Date.now is an integer",
      "Date.now > check Date.now is an integer (2)"
    ]
  },
  "library/page-close.spec.ts": {
    "failing": [
      "should close page with active dialog",
      "should not accept dialog after close",
      "expect should not print timed out error message when page closes",
      "addLocatorHandler should throw when page closes",
      "should reject all promises when page is closed",
      "should set the page close state",
      "should pass page to close event",
      "should terminate network waiters",
      "should be callable twice",
      "should return null if parent page has been closed",
      "should fail with error upon disconnect",
      "page.close should work with window.close",
      "should not throw UnhandledPromiseRejection when page closes",
      "interrupt request.response() and request.allHeaders() on page.close",
      "should not treat navigations as new popups",
      "should not result in unhandled rejection",
      "should reject response.finished if page closes",
      "should not throw when continuing while page is closing",
      "should not throw when continuing after page is closed"
    ]
  },
  "library/page-event-crash.spec.ts": {
    "failing": [
      "should emit crash event when page crashes",
      "should throw on any action after page crashes",
      "should cancel waitForEvent when page crashes",
      "should cancel navigation when page crashes",
      "should be able to close context when page crashes"
    ]
  },
  "library/pdf.spec.ts": {
    "failing": [
      "should be able to save file",
      "should be able to generate outline"
    ]
  },
  "library/permissions.spec.ts": {
    "failing": [
      "should support clipboard read",
      "storage access",
      "permissions > should be prompt by default",
      "permissions > should deny permission when not listed",
      "permissions > should fail when bad permission is given",
      "permissions > should grant geolocation permission when origin is listed",
      "permissions > should prompt for geolocation permission when origin is not listed",
      "permissions > should grant notifications permission when listed",
      "permissions > should accumulate when adding",
      "permissions > should clear permissions",
      "permissions > should grant permission when listed for all domains",
      "permissions > should grant permission when creating context",
      "permissions > should reset permissions",
      "permissions > should trigger permission onchange",
      "permissions > should isolate permissions between browser contexts",
      " > should be able to use the local-fonts API",
      "local network request is allowed from public origin"
    ]
  },
  "library/popup.spec.ts": {
    "failing": [
      "should inherit user agent from browser context @smoke",
      "should respect routes from browser context",
      "should inherit extra headers from browser context",
      "should inherit offline from browser context",
      "should inherit http credentials from browser context",
      "should inherit touch support from browser context",
      "should inherit viewport size from browser context",
      "should use viewport size from window features",
      "should respect routes from browser context when using window.open",
      "BrowserContext.addInitScript should apply to an in-process popup",
      "BrowserContext.addInitScript should apply to a cross-process popup",
      "should expose function from browser context",
      "should not dispatch binding on a closed page",
      "should not throttle rAF in the opener page",
      "should not throw when click closes popup"
    ]
  },
  "library/proxy.spec.ts": {
    "failing": [
      "should use proxy @smoke",
      "should use proxy for second page",
      "should work with IP:PORT notion",
      "should authenticate",
      "should work with authenticate followed by redirect",
      "should exclude patterns",
      "should use socks proxy",
      "should use socks proxy in second page",
      "does launch without a port",
      "should use SOCKS proxy for websocket requests",
      "should use http proxy for websocket requests",
      "should proxy local network requests > by default > localhost",
      "should proxy local network requests > by default > loopback address",
      "should proxy local network requests > by default > link-local",
      "should proxy local network requests > with other bypasses > localhost",
      "should proxy local network requests > with other bypasses > loopback address",
      "should proxy local network requests > with other bypasses > link-local"
    ],
    "skipped": [
      "should use proxy with emulated user agent"
    ]
  },
  "library/resource-timing.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work for subresource",
      "should work for SSL",
      "should work for redirect",
      "should work when serving from memory cache"
    ]
  },
  "library/role-utils.spec.ts": {
    "failing": [
      "wpt accname #0",
      "wpt accname #1",
      "wpt accname #2",
      "wpt accname #3",
      "wpt accname non-manual",
      "axe-core implicit-role",
      "axe-core accessible-text",
      "accessible name with slots",
      "accessible name nested treeitem",
      "svg title",
      "native controls",
      "native controls labelled-by",
      "display:contents should be visible when contents are visible",
      "should remove soft hyphens and zero-width spaces",
      "label/labelled-by aria-hidden with descendants",
      "own aria-label concatenated with aria-labelledby",
      "control embedded in a label",
      "control embedded in a target element",
      "svg role=presentation",
      "should work with form and tricky input names",
      "should ignore stylesheet from hidden aria-labelledby subtree",
      "should not include hidden pseudo into accessible name",
      "should resolve pseudo content from attr",
      "should resolve pseudo content alternative text",
      "should resolve css content property for an element",
      "should ignore invalid aria-labelledby",
      "should support search element"
    ]
  },
  "library/route-web-socket.spec.ts": {
    "failing": [
      "should work with ws.close",
      "should pattern match",
      "should work with server",
      "should work without server",
      "should emit close upon frame navigation",
      "should emit close upon frame detach",
      "should route on context",
      "should not throw after page closure",
      "should not throw with empty handler",
      "should throw when connecting twice",
      "should work with no trailing slash",
      "should work with baseURL",
      "no-mock > should work with text message",
      "no-mock > should work with binaryType=blob",
      "no-mock > should work with binaryType=arraybuffer",
      "no-mock > should work when connection errors out",
      "no-mock > should work with error after successful open",
      "no-mock > should work with client-side close",
      "no-mock > should pass through the required protocol",
      "no-mock > should work with relative WebSocket URL",
      "no-match > should work with text message",
      "no-match > should work with binaryType=blob",
      "no-match > should work with binaryType=arraybuffer",
      "no-match > should work when connection errors out",
      "no-match > should work with error after successful open",
      "no-match > should work with client-side close",
      "no-match > should pass through the required protocol",
      "no-match > should work with relative WebSocket URL",
      "pass-through > should work with text message",
      "pass-through > should work with binaryType=blob",
      "pass-through > should work with binaryType=arraybuffer",
      "pass-through > should work when connection errors out",
      "pass-through > should work with error after successful open",
      "pass-through > should work with client-side close",
      "pass-through > should pass through the required protocol",
      "pass-through > should work with relative WebSocket URL"
    ]
  },
  "library/screenshot.spec.ts": {
    "failing": [
      "page screenshot > should run in parallel in multiple pages",
      "page screenshot > should work with a mobile viewport",
      "page screenshot > should work with a mobile viewport and clip",
      "page screenshot > should work with a mobile viewport and fullPage",
      "page screenshot > should work with device scale factor",
      "page screenshot > should work with device scale factor and clip",
      "page screenshot > should work with device scale factor and scale:css",
      "page screenshot > should work with device scale factor, clip and scale:css",
      "page screenshot > should throw if screenshot size is too large with device scale factor",
      "page screenshot > should work with large size",
      "page screenshot > should handle vh units ",
      "element screenshot > element screenshot should work with a mobile viewport",
      "element screenshot > element screenshot should work with device scale factor",
      "element screenshot > should take screenshots when default viewport is null",
      "element screenshot > should take fullPage screenshots when default viewport is null",
      "element screenshot > should restore default viewport after fullPage screenshot",
      "element screenshot > should restore viewport after page screenshot and exception",
      "element screenshot > should restore viewport after page screenshot and timeout",
      "element screenshot > should take element screenshot when default viewport is null and restore back",
      "element screenshot > should restore viewport after element screenshot and exception",
      "element screenshot > element screenshots should handle vh units ",
      "element screenshot > should work if the main resource hangs",
      "element screenshot > should capture full element when larger than viewport with device scale factor",
      "element screenshot > should capture full element when larger than viewport with device scale factor and scale:css",
      "element screenshot > page screenshot should capture css transform with device pixels"
    ]
  },
  "library/selector-generator.spec.ts": {
    "failing": [
      "selector generator > should prefer button over inner span",
      "selector generator > should prefer role=button over inner span",
      "selector generator > should not prefer zero-sized button over inner span",
      "selector generator > should generate text and normalize whitespace",
      "selector generator > should not escape spaces inside named attr selectors",
      "selector generator > should generate text for <input type=button>",
      "selector generator > should trim text",
      "selector generator > should try to improve role name",
      "selector generator > should try to improve text",
      "selector generator > should try to improve text by shortening",
      "selector generator > should try to improve label text by shortening",
      "selector generator > should not improve guid text",
      "selector generator > should not escape text with >>",
      "selector generator > should escape text with quote",
      "selector generator > should escape text with slash",
      "selector generator > should not use text for select",
      "selector generator > should use ordinal for identical nodes",
      "selector generator > should prefer data-testid",
      "selector generator > should use data-testid in strict errors",
      "selector generator > should handle first non-unique data-testid",
      "selector generator > should handle second non-unique data-testid",
      "selector generator > should use readable id",
      "selector generator > should not use generated id",
      "selector generator > should use internal:has-text",
      "selector generator > should use internal:has-text with regexp",
      "selector generator > should use internal:has-text with regexp with a quote",
      "selector generator > should chain text after parent",
      "selector generator > should use parent text",
      "selector generator > should separate selectors by >>",
      "selector generator > should trim long text",
      "selector generator > should use nested ordinals",
      "selector generator > should prefer class to ordinal",
      "selector generator > should properly join child selectors under nested ordinals",
      "selector generator > should not use input[value]",
      "selector generator > should find text in shadow dom",
      "selector generator > should match in shadow dom",
      "selector generator > should match in deep shadow dom",
      "selector generator > should work in dynamic iframes without navigation",
      "selector generator > should use the name attributes for elements that can have it",
      "selector generator > should work with tricky attributes",
      "selector generator > should work without CSS.escape",
      "selector generator > should not over-escape for CSS syntax",
      "selector generator > should ignore empty aria-label for candidate consideration",
      "selector generator > should accept valid aria-label for candidate consideration",
      "selector generator > should ignore empty role for candidate consideration",
      "selector generator > should not accept invalid role for candidate consideration",
      "selector generator > should ignore empty data-test-id for candidate consideration",
      "selector generator > should accept valid data-test-id for candidate consideration",
      "selector generator > should generate label selector",
      "selector generator > should prefer role other input[type]",
      "selector generator > should generate title selector",
      "selector generator > should generate exact text when necessary",
      "selector generator > should generate exact title when necessary",
      "selector generator > should generate exact placeholder when necessary",
      "selector generator > should generate exact role when necessary",
      "selector generator > should generate exact label when necessary",
      "selector generator > should generate relative selector",
      "selector generator > should generate multiple: noText in role",
      "selector generator > should generate multiple: noText in text",
      "selector generator > should generate multiple: noId",
      "selector generator > should generate multiple: noId noText",
      "selector generator > should prefer role with hasText to css with hasText",
      "selector generator > should prioritize attributes correctly > role",
      "selector generator > should prioritize attributes correctly > placeholder",
      "selector generator > should prioritize attributes correctly > name",
      "selector generator > should prioritize attributes correctly > type",
      "selector generator > should not use icon fonts aria name"
    ]
  },
  "library/selectors-register.spec.ts": {
    "failing": [
      "should work",
      "should work when registered on global",
      "should work with path",
      "should work in main and isolated world",
      "should handle errors",
      "should not rely on engines working from the root",
      "should throw a nice error if the selector returns a bad value"
    ]
  },
  "library/shared-worker.spec.ts": {
    "failing": [
      "should survive shared worker restart"
    ]
  },
  "library/signals.spec.ts": {
    "failing": [
      "should close the browser when the node process closes",
      "should remove temp dir on process.exit",
      "signals > should report browser close signal 2",
      "signals > should close the browser on SIGINT",
      "signals > should close the browser on SIGTERM",
      "signals > should close the browser on SIGHUP",
      "signals > should kill the browser on double SIGINT and remove temp dir",
      "signals > should kill the browser on SIGINT + SIGTERM",
      "signals > should kill the browser on SIGTERM + SIGINT",
      "signals > should not prevent default SIGTERM handling after browser close"
    ]
  },
  "library/slowmo.spec.ts": {
    "failing": [
      "slowMo > Page SlowMo check",
      "slowMo > Page SlowMo click",
      "slowMo > Page SlowMo dblclick",
      "slowMo > Page SlowMo dispatchEvent",
      "slowMo > Page SlowMo fill",
      "slowMo > Page SlowMo focus",
      "slowMo > Page SlowMo goto",
      "slowMo > Page SlowMo hover",
      "slowMo > Page SlowMo press",
      "slowMo > Page SlowMo reload",
      "slowMo > Page SlowMo selectOption",
      "slowMo > Page SlowMo setInputFiles",
      "slowMo > Page SlowMo type",
      "slowMo > Page SlowMo uncheck",
      "slowMo > Frame SlowMo check",
      "slowMo > Frame SlowMo click",
      "slowMo > Frame SlowMo dblclick",
      "slowMo > Frame SlowMo dispatchEvent",
      "slowMo > Frame SlowMo fill",
      "slowMo > Frame SlowMo focus",
      "slowMo > Frame SlowMo goto",
      "slowMo > Frame SlowMo hover",
      "slowMo > Frame SlowMo press",
      "slowMo > Frame SlowMo selectOption",
      "slowMo > Frame SlowMo setInputFiles",
      "slowMo > Frame SlowMo type",
      "slowMo > Frame SlowMo uncheck",
      "slowMo > ElementHandle SlowMo check",
      "slowMo > ElementHandle SlowMo click",
      "slowMo > ElementHandle SlowMo dblclick",
      "slowMo > ElementHandle SlowMo dispatchEvent",
      "slowMo > ElementHandle SlowMo fill",
      "slowMo > ElementHandle SlowMo focus",
      "slowMo > ElementHandle SlowMo hover",
      "slowMo > ElementHandle SlowMo press",
      "slowMo > ElementHandle SlowMo selectOption",
      "slowMo > ElementHandle SlowMo setInputFiles",
      "slowMo > ElementHandle SlowMo type",
      "slowMo > ElementHandle SlowMo uncheck"
    ]
  },
  "library/tap.spec.ts": {
    "failing": [
      "should send all of the correct events @smoke",
      "trial run should not tap",
      "should not send mouse events touchstart is canceled",
      "should not send mouse events when touchend is canceled",
      "should not wait for a navigation caused by a tap",
      "should work with modifiers",
      "should send well formed touch points",
      "should wait until an element is visible to tap it",
      "locators > should send all of the correct events"
    ]
  },
  "library/trace-viewer.spec.ts": {
    "failing": [
      "should show empty trace viewer"
    ],
    "skipped": [
      "should open two trace viewers",
      "should open trace viewer on specific host",
      "should show tracing.group in the action list with location",
      "should open simple trace viewer",
      "should show action context on locators and other common actions",
      "should complain about newer version of trace in old viewer",
      "should properly synchronize local and remote time",
      "should contain action info",
      "should render network bars",
      "should render console",
      "should open console errors on click",
      "should show params and return value",
      "should show null as a param",
      "should have correct snapshot size",
      "should have correct stack trace",
      "should have network requests",
      "should filter network requests by resource type",
      "should show font preview",
      "should filter network requests by url",
      "should have network request overrides",
      "should have network request overrides 2",
      "should popup snapshot",
      "should capture iframe with sandbox attribute",
      "should capture data-url svg iframe",
      "should contain adopted style sheets",
      "should work with adopted style sheets and replace/replaceSync",
      "should work with adopted style sheets and all: unset",
      "should work with nesting CSS selectors",
      "should restore scroll positions",
      "should restore control values",
      "should work with meta CSP",
      "should handle multiple headers",
      "should handle src=blob",
      "should handle file URIs",
      "should preserve currentSrc",
      "should register custom elements",
      "should highlight target elements",
      "should highlight target element in shadow dom",
      "should highlight expect failure",
      "should show action source",
      "should follow redirects",
      "should include metainfo",
      "should not crash with broken locator",
      "should serve overridden request",
      "should display waitForLoadState even if did not wait for it",
      "should display language-specific locators",
      "should pick locator",
      "should update highlight when typing locator",
      "should update highlight when typing snapshot",
      "should open trace-1.31",
      "should open trace-1.37",
      "should prefer later resource request with the same method",
      "should ignore 304 responses",
      "should pick locator in iframe",
      "should highlight locator in iframe while typing",
      "should preserve noscript when javascript is disabled",
      "should remove noscript by default",
      "should remove noscript when javaScriptEnabled is set to true",
      "should open snapshot in new browser context",
      "should show similar actions from legacy library-only trace",
      "should show correct request start time",
      "should not record route actions",
      "should not record network actions",
      "should show baseURL in metadata pane",
      "should not leak recorders",
      "should serve css without content-type",
      "canvas disabled title",
      "canvas clipping",
      "canvas clipping in iframe",
      "should show only one pointer with multilevel iframes",
      "should show a popover",
      "should show a modal dialog",
      "should open settings dialog",
      "should toggle theme color",
      "should toggle canvas rendering",
      "should render blob trace received from message",
      "shouldn't render not-blob trace received from message",
      "should not trip over complex urls in style tags",
      "should render locator descriptions",
      "should load trace from HTTP with progress indicator",
      "should filter actions",
      "should survive service worker restart",
      " > should handle failed snapshots due to dialog",
      "should open v6 trace file",
      "should filter network requests by multiple resource types",
      "should show snapshot URL and copy button",
      "should open uncompressed trace directory",
      "should syntax highlight body",
      "should generate aria snapshot with unaltered urls",
      "should reflect system color scheme changes in document theme",
      "should not navigate on anchor clicks",
      "empty adopted style sheets should not prevent node refs",
      "should respect CSSOM changes",
      "should preserve custom doctype",
      "should replace meta charset attr that specifies charset",
      "should replace meta content attr that specifies charset",
      "should capture iframe with srcdoc"
    ]
  },
  "library/tracing.spec.ts": {
    "failing": [
      "should collect trace with resources, but no js",
      "should use the correct title for event driven callbacks",
      "should not collect snapshots by default",
      "can call tracing.group/groupEnd at any time and auto-close",
      "should not include buffers in the trace",
      "should exclude internal pages",
      "should include context API requests",
      "should collect two traces",
      "should respect tracesDir and name",
      "should not include trace resources from the previous chunks",
      "should overwrite existing file",
      "should collect sources",
      "should record network failures",
      "should not crash when browser closes mid-trace",
      "should survive browser.close with auto-created traces dir",
      "should not stall on dialogs",
      "should produce screencast frames fit",
      "should produce screencast frames crop",
      "should produce screencast frames scale",
      "should include interrupted actions",
      "should throw when starting with different options",
      "should throw when stopping without start",
      "should not throw when stopping without start but not exporting",
      "should work with multiple chunks",
      "should export trace concurrently to second navigation",
      "should not hang for clicks that open dialogs",
      "should ignore iframes in head",
      "should hide internal stack frames",
      "should hide internal stack frames in expect",
      "should record global request trace",
      "should not flush console events",
      "should flush console events on tracing stop",
      "should not emit after w/o before"
    ]
  },
  "library/unroute-behavior.spec.ts": {
    "failing": [
      "context.unroute should not wait for pending handlers to complete",
      "context.unrouteAll removes all handlers",
      "context.unrouteAll should wait for pending handlers to complete",
      "context.unrouteAll should not wait for pending handlers to complete if behavior is ignoreErrors",
      "page.close should not wait for active route handlers on the owning context",
      "context.close should not wait for active route handlers on the owned pages",
      "page.unroute should not wait for pending handlers to complete",
      "page.unrouteAll removes all routes",
      "page.unrouteAll should wait for pending handlers to complete",
      "page.unrouteAll should not wait for pending handlers to complete if behavior is ignoreErrors",
      "page.close does not wait for active route handlers",
      "route.continue should not throw if page has been closed",
      "route.fallback should not throw if page has been closed",
      "route.fulfill should not throw if page has been closed",
      "should not continue requests in flight (page)",
      "should not continue requests in flight (context)"
    ]
  },
  "library/video.spec.ts": {
    "failing": [
      "should saveAs video",
      "screencast > videoSize should require videosPath",
      "screencast > should work with old options",
      "screencast > should throw without recordVideo.dir",
      "screencast > should capture static page",
      "screencast > should continue recording main page after popup closes",
      "screencast > should expose video path",
      "screencast > saveAs should throw when no video frames",
      "screencast > should delete video",
      "screencast > should expose video path blank page",
      "screencast > should work with weird screen resolution",
      "screencast > should work with relative path for recordVideo.dir",
      "screencast > should expose video path blank popup",
      "screencast > should capture navigation",
      "screencast > should capture css transformation",
      "screencast > should work for popups",
      "screencast > should scale frames down to the requested size ",
      "screencast > should use viewport scaled down to fit into 800x800 as default size",
      "screencast > should be 800x450 by default",
      "screencast > should be 800x600 with null viewport",
      "screencast > should capture static page in persistent context @smoke",
      "screencast > should emulate an iphone",
      "screencast > should throw on browser close",
      "screencast > should throw if browser dies",
      "screencast > should wait for video to finish if page was closed",
      "screencast > should not create video for internal pages",
      "screencast > should work with video+trace"
    ],
    "skipped": [
      "screencast > should capture full viewport",
      "screencast > should capture full viewport on hidpi"
    ]
  },
  "library/web-socket.spec.ts": {
    "failing": [
      "should work @smoke",
      "should emit close events",
      "should emit frame events",
      "should filter out the close events when the server closes with a message",
      "should pass self as argument to close event",
      "should emit binary frame events",
      "should emit error",
      "should not have stray error events",
      "should reject waitForEvent on socket close",
      "should reject waitForEvent on page close",
      "should turn off when offline"
    ]
  },
  "page/elementhandle-bounding-box.spec.ts": {
    "failing": [
      "should work",
      "should handle nested frames",
      "should get frame box",
      "should handle scroll offset and click",
      "should return null for invisible elements",
      "should force a layout",
      "should work with SVG nodes",
      "should work when inline box child is outside of viewport"
    ]
  },
  "page/elementhandle-click.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with Node removed",
      "should work for Shadow DOM v1",
      "should work for TextNodes",
      "should throw for detached nodes",
      "should throw for hidden nodes with force",
      "should throw for recursively hidden nodes with force",
      "should throw for <br> elements with force",
      "should double click the button"
    ]
  },
  "page/elementhandle-content-frame.spec.ts": {
    "failing": [
      "should work",
      "should work for cross-process iframes",
      "should work for cross-frame evaluations",
      "should return null for non-iframes",
      "should return null for document.documentElement"
    ]
  },
  "page/elementhandle-convenience.spec.ts": {
    "failing": [
      "should have a nice preview",
      "should have a nice preview for non-ascii attributes/children",
      "getAttribute should work",
      "inputValue should work",
      "innerHTML should work",
      "innerText should work",
      "innerText should throw",
      "textContent should work",
      "textContent should work on ShadowRoot",
      "isVisible and isHidden should work",
      "isVisible should not throw when the DOM element is not connected",
      "isEnabled and isDisabled should work",
      "isEnabled and isDisabled should work with <select/> option/optgroup correctly",
      "isEditable should work",
      "isChecked should work"
    ]
  },
  "page/elementhandle-eval-on-selector.spec.ts": {
    "failing": [
      "should work",
      "should retrieve content from subtree",
      "should throw in case of missing selector",
      "should work for all",
      "should retrieve content from subtree for all",
      "should not throw in case of missing selector for all"
    ]
  },
  "page/elementhandle-misc.spec.ts": {
    "failing": [
      "should hover",
      "should hover when Node is removed",
      "should fill input",
      "should fill input when Node is removed",
      "should check the box",
      "should check the box using setChecked",
      "should uncheck the box",
      "should select single option",
      "should focus a button",
      "should allow disposing twice"
    ]
  },
  "page/elementhandle-owner-frame.spec.ts": {
    "failing": [
      "should work",
      "should work for cross-process iframes",
      "should work for document",
      "should work for iframe elements",
      "should work for cross-frame evaluations",
      "should work for detached elements",
      "should work for adopted elements"
    ]
  },
  "page/elementhandle-press.spec.ts": {
    "failing": [
      "should work",
      "should not select existing value",
      "should reset selection when not focused",
      "should not modify selection when focused",
      "should work with number input"
    ]
  },
  "page/elementhandle-query-selector.spec.ts": {
    "failing": [
      "should query existing element",
      "should return null for non-existing element",
      "should work for adopted elements",
      "should query existing elements",
      "should return empty array for non-existing elements",
      "xpath should query existing element",
      "xpath should return null for non-existing element"
    ]
  },
  "page/elementhandle-screenshot.spec.ts": {
    "failing": [
      "element screenshot > should work",
      "element screenshot > should work when main world busts JSON.stringify",
      "element screenshot > should take into account padding and border",
      "element screenshot > should capture full element when larger than viewport in parallel",
      "element screenshot > should capture full element when larger than viewport",
      "element screenshot > should scroll element into view",
      "element screenshot > should scroll 15000px into view",
      "element screenshot > should work with a rotated element",
      "element screenshot > should fail to screenshot a detached element",
      "element screenshot > should timeout waiting for visible",
      "element screenshot > should wait for visible",
      "element screenshot > should work for an element with fractional dimensions",
      "element screenshot > should work for an element with an offset",
      "element screenshot > should wait for element to stop moving",
      "element screenshot > should take screenshot of disabled button",
      "element screenshot > path option should create subdirectories",
      "element screenshot > should prefer type over extension",
      "element screenshot > should not issue resize event"
    ]
  },
  "page/elementhandle-scroll-into-view.spec.ts": {
    "failing": [
      "should work @smoke",
      "should throw for detached element",
      "should wait for display:none to become visible",
      "should scroll display:contents into view",
      "should work for visibility:hidden element",
      "should work for zero-sized element",
      "should wait for nested display:none to become visible",
      "should wait for element to stop moving",
      "should timeout waiting for visible"
    ]
  },
  "page/elementhandle-select-text.spec.ts": {
    "failing": [
      "should select textarea",
      "should select input",
      "should select plain div",
      "should timeout waiting for invisible element",
      "should wait for visible"
    ]
  },
  "page/elementhandle-type.spec.ts": {
    "failing": [
      "should work",
      "should not select existing value",
      "should reset selection when not focused",
      "should not modify selection when focused",
      "should work with number input"
    ]
  },
  "page/elementhandle-wait-for-element-state.spec.ts": {
    "failing": [
      "should wait for visible",
      "should wait for already visible",
      "should timeout waiting for visible",
      "should throw waiting for visible when detached",
      "should wait for hidden",
      "should wait for already hidden",
      "should wait for hidden when detached",
      "should throw waiting for enabled when detached",
      "should wait for aria enabled button",
      "should wait for button with an aria-disabled parent",
      "should wait for stable position",
      "should wait for editable input"
    ]
  },
  "page/eval-on-selector-all.spec.ts": {
    "failing": [
      "should work with css selector",
      "should work with text selector",
      "should work with xpath selector",
      "should auto-detect css selector",
      "should support >> syntax",
      "should support * capture",
      "should support * capture when multiple paths match",
      "should return complex values",
      "should work with bogus Array.from"
    ]
  },
  "page/eval-on-selector.spec.ts": {
    "failing": [
      "should work with css selector",
      "should work with id selector",
      "should work with data-test selector",
      "should work with data-testid selector",
      "should work with data-test-id selector",
      "should work with text selector in quotes",
      "should work with xpath selector",
      "should work with text selector",
      "should auto-detect css selector",
      "should auto-detect css selector with attributes",
      "should auto-detect nested selectors",
      "should accept arguments",
      "should accept ElementHandles as arguments",
      "should throw error if no element is found",
      "should support >> syntax",
      "should support >> syntax with different engines",
      "should support spaces with >> syntax",
      "should not stop at first failure with >> syntax",
      "should support * capture",
      "should throw on multiple * captures",
      "should throw on malformed * capture",
      "should work with spaces in css attributes",
      "should work with quotes in css attributes",
      "should work with spaces in css attributes when missing",
      "should work with quotes in css attributes when missing",
      "should return complex values"
    ]
  },
  "page/expect-boolean.spec.ts": {
    "failing": [
      "toBeEmpty input",
      "not.toBeEmpty",
      "toBeEmpty div",
      "toBeDisabled with value",
      "toBeChecked with value",
      "toBeHidden with value",
      "not.toBeDisabled div",
      "toBeFocused",
      "toBeFocused with shadow elements",
      "should print unknown engine error",
      "should print selector syntax error",
      "toBeChecked > default",
      "toBeChecked > with checked:true",
      "toBeChecked > with checked:false",
      "toBeChecked > with indeterminate:true",
      "toBeChecked > with indeterminate:true and checked",
      "toBeChecked > fail",
      "toBeChecked > with not",
      "toBeChecked > with not and checked:false",
      "toBeChecked > fail with not",
      "toBeChecked > fail with checked:false",
      "toBeChecked > fail with indeterminate: true",
      "toBeChecked > fail missing",
      "toBeChecked > with role",
      "toBeChecked > friendly log",
      "toBeChecked > with impossible timeout",
      "toBeChecked > with impossible timeout .not",
      "toBeEditable > default",
      "toBeEditable > with not",
      "toBeEditable > with editable:true",
      "toBeEditable > with editable:false",
      "toBeEditable > with not and editable:false",
      "toBeEditable > throws",
      "toBeEnabled > default",
      "toBeEnabled > with enabled:true",
      "toBeEnabled > with enabled:false",
      "toBeEnabled > failed",
      "toBeEnabled > eventually",
      "toBeEnabled > eventually with not",
      "toBeEnabled > with not and enabled:false",
      "toBeEnabled > toBeDisabled",
      "toBeVisible > default",
      "toBeVisible > with not",
      "toBeVisible > with visible:true",
      "toBeVisible > with visible:false",
      "toBeVisible > with not and visible:false",
      "toBeVisible > eventually",
      "toBeVisible > eventually with not",
      "toBeVisible > fail",
      "toBeVisible > fail with not",
      "toBeVisible > with impossible timeout",
      "toBeVisible > with impossible timeout .not",
      "toBeVisible > with frameLocator",
      "toBeVisible > with frameLocator 2",
      "toBeVisible > over navigation",
      "toBeHidden > default",
      "toBeHidden > when nothing matches",
      "toBeHidden > with not",
      "toBeHidden > eventually with not",
      "toBeHidden > eventually",
      "toBeHidden > fail",
      "toBeHidden > fail with not",
      "toBeHidden > fail with not when nothing matching",
      "toBeHidden > with impossible timeout .not",
      "toBeHidden > with impossible timeout",
      " > toBeOK",
      " > not.toBeOK",
      " > toBeOK fail with invalid argument",
      " > toBeOK fail with promise",
      " > toBeOK should print response with text content type when fails > text content type",
      " > toBeOK should print response with text content type when fails > no content type",
      " > toBeOK should print response with text content type when fails > image content type",
      "toBeAttached > default",
      "toBeAttached > with hidden element",
      "toBeAttached > with not",
      "toBeAttached > with attached:true",
      "toBeAttached > with attached:false",
      "toBeAttached > with not and attached:false",
      "toBeAttached > eventually",
      "toBeAttached > eventually with not",
      "toBeAttached > fail",
      "toBeAttached > fail with not",
      "toBeAttached > with impossible timeout",
      "toBeAttached > with impossible timeout .not",
      "toBeAttached > with frameLocator",
      "toBeAttached > over navigation"
    ]
  },
  "page/expect-matcher-result.spec.ts": {
    "failing": [
      "toMatchText-based assertions should have matcher result",
      "toBeTruthy-based assertions should have matcher result",
      "toEqual-based assertions should have matcher result",
      "toBeChecked({ checked }) should have expected",
      "toHaveScreenshot should populate matcherResult"
    ]
  },
  "page/expect-misc.spec.ts": {
    "failing": [
      "toHaveCount should not produce logs twice",
      "toHaveText should not produce logs twice",
      "toHaveText that does not match should not produce logs twice",
      "strict mode violation error format",
      "invalid selector error format",
      "toHaveCount > toHaveCount pass",
      "toHaveCount > pass zero",
      "toHaveCount > eventually pass zero",
      "toHaveCount > eventually pass non-zero",
      "toHaveCount > eventually pass not non-zero",
      "toHaveCount > fail zero",
      "toHaveCount > fail zero 2",
      "toHaveJSProperty > pass",
      "toHaveJSProperty > fail",
      "toHaveJSProperty > pass string",
      "toHaveJSProperty > fail string",
      "toHaveJSProperty > pass number",
      "toHaveJSProperty > fail number",
      "toHaveJSProperty > pass boolean",
      "toHaveJSProperty > fail boolean",
      "toHaveJSProperty > pass boolean 2",
      "toHaveJSProperty > fail boolean 2",
      "toHaveJSProperty > pass undefined",
      "toHaveJSProperty > pass null",
      "toHaveJSProperty > pass nested",
      "toHaveJSProperty > fail nested",
      "toHaveClass > pass",
      "toHaveClass > pass with SVGs",
      "toHaveClass > fail",
      "toHaveClass > pass with array",
      "toHaveClass > fail with array",
      "toContainClass > pass",
      "toContainClass > pass with SVGs",
      "toContainClass > fail",
      "toContainClass > pass with array",
      "toContainClass > fail with array",
      "toHaveTitle > pass",
      "toHaveTitle > fail",
      "toHaveURL > pass",
      "toHaveURL > fail string",
      "toHaveURL > fail with invalid argument",
      "toHaveURL > fail with positive predicate",
      "toHaveURL > fail with negative predicate",
      "toHaveURL > resolve predicate on initial call",
      "toHaveURL > resolve predicate after retries",
      "toHaveURL > support ignoreCase",
      "toHaveAttribute > pass",
      "toHaveAttribute > should not match missing attribute",
      "toHaveAttribute > should match boolean attribute",
      "toHaveAttribute > should match attribute without value",
      "toHaveAttribute > should support boolean attribute with options",
      "toHaveAttribute > support ignoreCase",
      "toHaveId > pass",
      "toBeInViewport > should work",
      "toBeInViewport > should respect ratio option",
      "toBeInViewport > should have good stack",
      "toBeInViewport > should report intersection even if fully covered by other element",
      "toHaveCSS > pass with css property",
      "toHaveCSS > pass with custom css property",
      "toHaveCSS > pass with CSSPProperties object",
      "toHaveCSS > pass with CSSPProperties object with camelCased properties",
      "toHaveCSS > pass with CSSPProperties object with vendor-prefixed properties",
      "toHaveCSS > pass with CSSPProperties object with custom properties"
    ]
  },
  "page/expect-timeout.spec.ts": {
    "failing": [
      "should print element not found",
      "should print timed out error message when value does not match",
      "should print timed out error message with impossible timeout",
      "should print timed out error message when value does not match with impossible timeout",
      "should have timeout error name",
      "should not throw when navigating during one-shot check",
      "should not throw when navigating during first locator handler check",
      "should timeout during first locator handler check"
    ]
  },
  "page/expect-to-have-accessible.spec.ts": {
    "failing": [
      "toHaveAccessibleName",
      "toHaveAccessibleDescription",
      "toHaveAccessibleErrorMessage",
      "toHaveAccessibleErrorMessage should handle multiple aria-errormessage references",
      "should show error message when validity is false and aria-invalid is true",
      "should show error message when validity is true and aria-invalid is true",
      "should show error message when validity is false and aria-invalid is false",
      "should not show error message when validity is true and aria-invalid is false",
      "should show error message for all roles",
      "toHaveRole",
      "toHaveAccessibleErrorMessage should handle aria-invalid attribute > evaluated in false > no aria-invalid attribute",
      "toHaveAccessibleErrorMessage should handle aria-invalid attribute > evaluated in false > aria-invalid=\"false\"",
      "toHaveAccessibleErrorMessage should handle aria-invalid attribute > evaluated in false > aria-invalid=\"\" (empty string)",
      "toHaveAccessibleErrorMessage should handle aria-invalid attribute > evaluated in true > aria-invalid=\"true\"",
      "toHaveAccessibleErrorMessage should handle aria-invalid attribute > evaluated in true > aria-invalid=\"foo\" (unrecognized value)"
    ]
  },
  "page/expect-to-have-text.spec.ts": {
    "failing": [
      "toHaveText with regex > pass",
      "toHaveText with regex > fail",
      "toContainText with regex > pass",
      "toContainText with regex > fail",
      "toContainText with string > pass",
      "toContainText with string > fail",
      "toHaveText with text > pass",
      "toHaveText with text > pass contain",
      "toHaveText with text > fail",
      "toHaveText with text > pass eventually",
      "toHaveText with text > with userInnerText",
      "toHaveText with text > in shadow dom",
      "toHaveText with text > fail with impossible timeout",
      "not.toHaveText > pass",
      "not.toHaveText > fail",
      "not.toHaveText > should work when selector does not match",
      "toHaveText with array > pass",
      "toHaveText with array > pass lazy",
      "toHaveText with array > pass empty",
      "toHaveText with array > pass not empty",
      "toHaveText with array > pass on empty",
      "toHaveText with array > fail on not+empty",
      "toHaveText with array > pass eventually empty",
      "toHaveText with array > fail",
      "toHaveText with array > fail on repeating array matchers",
      "toContainText with array > pass",
      "toContainText with array > fail",
      "toHaveText with text > do not show \"element(s) not found\" when the real failure is a string mismatch"
    ]
  },
  "page/expect-to-have-value.spec.ts": {
    "failing": [
      "should work",
      "should work with label",
      "should work with regex",
      "should support failure",
      "toHaveValues with multi-select > works with text",
      "toHaveValues with multi-select > follows labels",
      "toHaveValues with multi-select > exact match with text failure",
      "toHaveValues with multi-select > works with regex",
      "toHaveValues with multi-select > fails when items not selected",
      "toHaveValues with multi-select > fails when multiple not specified",
      "toHaveValues with multi-select > fails when not a select element"
    ]
  },
  "page/frame-evaluate.spec.ts": {
    "failing": [
      "should have different execution contexts",
      "should have correct execution contexts @smoke",
      "should dispose context on navigation",
      "should dispose context on cross-origin navigation",
      "should execute after cross-site navigation",
      "should not allow cross-frame js handles",
      "should allow cross-frame element handles",
      "should not allow cross-frame element handles when frames do not script each other",
      "should throw for detached frames",
      "should be isolated between frames",
      "should work in iframes that failed initial navigation",
      "should work in iframes that interrupted initial javascript url navigation",
      "evaluateHandle should work"
    ]
  },
  "page/frame-frame-element.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with contentFrame",
      "should work with frameset",
      "should throw when detached",
      "should work inside closed shadow root",
      "should work inside declarative shadow root"
    ]
  },
  "page/frame-goto.spec.ts": {
    "failing": [
      "should navigate subframes @smoke",
      "should reject when frame detaches",
      "should continue after client redirect",
      "should return matching responses"
    ]
  },
  "page/frame-hierarchy.spec.ts": {
    "failing": [
      "should handle nested frames @smoke",
      "should send events when frames are manipulated dynamically",
      "should send \"framenavigated\" when navigating on anchor URLs",
      "should persist mainFrame on cross-process navigation",
      "should not send attach/detach events for main frame",
      "should detach child frames on navigation",
      "should support framesets",
      "should report frame from-inside shadow DOM",
      "should report frame.name()",
      "should report frame.parent()",
      "should report different frame instance when frame re-attaches",
      "should refuse to display x-frame-options:deny iframe",
      "should return frame.page()"
    ]
  },
  "page/interception.spec.ts": {
    "failing": [
      "should work with navigation @smoke",
      "should intercept after a service worker",
      "should intercept by glob",
      "should intercept network activity from worker",
      "should intercept worker requests when enabled after worker creation",
      "should intercept network activity from worker 2",
      "should work with regular expression passed from a different context",
      "should not break remote worker importScripts",
      "should disable memory cache when intercepting",
      "should intercept blob url requests"
    ]
  },
  "page/jshandle-as-element.spec.ts": {
    "failing": [
      "should work @smoke",
      "should return null for non-elements",
      "should return ElementHandle for TextNodes",
      "should work with nullified Node"
    ]
  },
  "page/jshandle-evaluate.spec.ts": {
    "failing": [
      "should work with function @smoke",
      "should work with expression"
    ]
  },
  "page/jshandle-json-value.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with dates",
      "should handle circular objects"
    ]
  },
  "page/jshandle-properties.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with undefined, null, and empty",
      "should work with unserializable values",
      "getProperties should work",
      "getProperties should return empty map for non-objects",
      "getProperties should return even non-own properties",
      "getProperties should work with elements"
    ]
  },
  "page/jshandle-to-string.spec.ts": {
    "failing": [
      "should work for primitives",
      "should work for complicated objects",
      "should beautifully render sparse arrays",
      "should work for promises",
      "should work with different subtypes @smoke",
      "should work with previewable subtypes"
    ]
  },
  "page/locator-click.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with Node removed",
      "should double click the button",
      "should click if the target element is removed in pointerup event",
      "should click if the target element is removed in pointerdown event"
    ]
  },
  "page/locator-convenience.spec.ts": {
    "failing": [
      "should have a nice preview",
      "getAttribute should work",
      "inputValue should work",
      "innerHTML should work",
      "innerText should work",
      "innerText should throw",
      "innerText should produce log",
      "textContent should work",
      "isEnabled and isDisabled should work",
      "isEditable should work",
      "isChecked should work",
      "isChecked should work for indeterminate input",
      "allTextContents should work",
      "allInnerTexts should work",
      "should return page",
      "description should return null for locator without description",
      "description should return description for locator with simple description",
      "description should return description with special characters",
      "description should return description for chained locators",
      "description should return description for locator with multiple describe calls",
      "toString() returns formatted locator",
      "toString() prefers description"
    ]
  },
  "page/locator-element-handle.spec.ts": {
    "failing": [
      "should query existing element @smoke",
      "should query existing elements",
      "should return empty array for non-existing elements",
      "xpath should query existing element",
      "xpath should return null for non-existing element"
    ]
  },
  "page/locator-evaluate.spec.ts": {
    "failing": [
      "should work @smoke",
      "should retrieve content from subtree",
      "should work for all",
      "should retrieve content from subtree for all",
      "should not throw in case of missing selector for all",
      "should allow calling _evaluateFunction"
    ]
  },
  "page/locator-frame.spec.ts": {
    "failing": [
      "should work for iframe @smoke",
      "should work for nested iframe",
      "should work for $ and $$",
      "should wait for frame",
      "should wait for frame 2",
      "should wait for frame to go",
      "should not wait for frame",
      "should not wait for frame 2",
      "should not wait for frame 3",
      "should click in lazy iframe",
      "waitFor should survive frame reattach",
      "click should survive frame reattach",
      "click should survive iframe navigation",
      "should non work for non-frame",
      "locator.frameLocator should work for iframe",
      "locator.frameLocator should throw on ambiguity",
      "locator.frameLocator should not throw on first/last/nth",
      "getBy coverage",
      "wait for hidden should succeed when frame is not in dom",
      "should work with COEP/COOP/CORP isolated iframe",
      "locator.contentFrame should work",
      "frameLocator.owner should work"
    ]
  },
  "page/locator-highlight.spec.ts": {
    "failing": [
      "should highlight locator"
    ]
  },
  "page/locator-is-visible.spec.ts": {
    "failing": [
      "isVisible and isHidden should work",
      "isVisible should be true for opacity:0",
      "isVisible should be true for element outside view",
      "isVisible and isHidden should work with details",
      "isVisible inside a button",
      "isVisible inside a role=button",
      "isVisible during navigation should not throw",
      "isVisible with invalid selector should throw"
    ]
  },
  "page/locator-list.spec.ts": {
    "failing": [
      "locator.all should work"
    ]
  },
  "page/locator-misc-1.spec.ts": {
    "failing": [
      "should hover @smoke",
      "should hover when Node is removed",
      "should fill input",
      "should fill input when Node is removed",
      "should clear input",
      "should check the box",
      "should check the box using setChecked",
      "should uncheck the box",
      "should select single option",
      "should focus and blur a button",
      "focus should respect strictness",
      "should dispatch click event via ElementHandles",
      "should upload the file"
    ]
  },
  "page/locator-misc-2.spec.ts": {
    "failing": [
      "should press @smoke",
      "should scroll into view",
      "should scroll zero-sized element into view",
      "should select textarea",
      "should type",
      "should pressSequentially",
      "should take screenshot",
      "should return bounding box",
      "should waitFor",
      "should waitFor hidden",
      "should combine visible with other selectors",
      "should support filter(visible)",
      "locator.count should work with deleted Map in main world",
      "Locator.locator() and FrameLocator.locator() should accept locator",
      "should fill programmatically enabled textarea",
      "press should throw on unknown keys"
    ]
  },
  "page/locator-query.spec.ts": {
    "failing": [
      "should respect first() and last() @smoke",
      "should respect nth()",
      "should throw on capture w/ nth()",
      "should throw on due to strictness",
      "should throw on due to strictness 2",
      "should filter by text",
      "should filter by text 2",
      "should filter by regex",
      "should filter by text with quotes",
      "should filter by regex with quotes",
      "should filter by regex with a single quote",
      "should filter by regex and regexp flags",
      "should filter by case-insensitive regex in a child",
      "should filter by case-insensitive regex in multiple children",
      "should filter by regex with special symbols",
      "should support has:locator",
      "should support locator.filter",
      "should support locator.and",
      "should support locator.or",
      "should support locator.locator with and/or",
      "should allow some, but not all nested frameLocators",
      "should enforce same frame for has/leftOf/rightOf/above/below/near",
      "alias methods coverage",
      "count() should not throw during navigation"
    ]
  },
  "page/matchers.misc.spec.ts": {
    "failing": [
      "should outlive frame navigation",
      "should print no-locator-resolved error when locator matcher did not resolve to any element"
    ]
  },
  "page/network-post-data.spec.ts": {
    "failing": [
      "should return correct postData buffer for utf-8 body",
      "should return post data w/o content-type @smoke",
      "should throw on invalid JSON in post data",
      "should return post data for PUT requests",
      "should get post data for file/blob",
      "should get post data for navigator.sendBeacon api calls"
    ]
  },
  "page/page-add-init-script.spec.ts": {
    "failing": [
      "should evaluate before anything else on the page",
      "should work with a path",
      "should work with content @smoke",
      "should throw without path and content",
      "should work with trailing comments",
      "should support multiple scripts",
      "should work with CSP",
      "should work after a cross origin navigation",
      "init script should run only once in iframe"
    ]
  },
  "page/page-add-locator-handler.spec.ts": {
    "failing": [
      "should work",
      "should work with a custom check",
      "should work with locator.hover()",
      "should not work with force:true",
      "should throw when handler times out",
      "should work with toBeVisible",
      "should work with locator.waitFor",
      "should work with toHaveScreenshot",
      "should work when owner frame detaches",
      "should work with times: option",
      "should wait for hidden by default",
      "should wait for hidden by default 2",
      "should work with noWaitAfter",
      "should removeLocatorHandler"
    ]
  },
  "page/page-add-script-tag.spec.ts": {
    "failing": [
      "should throw an error if no options are provided",
      "should work with a url",
      "should work with a url and type=module",
      "should work with a path and type=module",
      "should work with a content and type=module",
      "should throw an error if loading from url fail",
      "should work with a path",
      "should include sourceURL when path is provided",
      "should work with content",
      "should throw when added with content to the CSP page",
      "should throw when added with URL to the CSP page",
      "should throw a nice error when the request fails"
    ]
  },
  "page/page-add-style-tag.spec.ts": {
    "failing": [
      "should throw an error if no options are provided",
      "should work with a url @smoke",
      "should throw an error if loading from url fail",
      "should work with a path",
      "should include sourceURL when path is provided",
      "should work with content",
      "should throw when added with content to the CSP page",
      "should throw when added with URL to the CSP page"
    ]
  },
  "page/page-aria-snapshot-ai.spec.ts": {
    "failing": [
      "should generate refs",
      "should list iframes",
      "should stitch all frame snapshots",
      "should not generate refs for elements with pointer-events:none",
      "emit generic roles for nodes w/o roles",
      "should collapse generic nodes",
      "should include cursor pointer hint",
      "should not nest cursor pointer hints",
      "should gracefully fallback when child frame cant be captured",
      "should auto-wait for navigation",
      "should auto-wait for blocking CSS",
      "should show visible children of hidden elements",
      "should include active element information",
      "should update active element on focus",
      "should mark iframe as active when it contains focused element",
      "return empty snapshot when iframe is not loaded",
      "should support many properties on iframes",
      "should collapse inline generic nodes",
      "should not remove generic nodes with title",
      "should create incremental snapshots on multiple tracks",
      "should create incremental snapshot for attribute change",
      "should create incremental snapshot for child removal",
      "should create incremental snapshot for child addition",
      "should create incremental snapshot for prop change",
      "should create incremental snapshot for cursor change",
      "should create incremental snapshot for name change",
      "should create incremental snapshot for text change",
      "should persist iframe references",
      "should not create incremental snapshots without tracks",
      "should create incremental snapshot for children swap",
      "should create multiple chunks in incremental snapshot",
      "should produce incremental snapshot for iframes"
    ]
  },
  "page/page-aria-snapshot.spec.ts": {
    "failing": [
      "should snapshot",
      "should snapshot list",
      "should snapshot list with accessible name",
      "should snapshot complex",
      "should allow text nodes",
      "should snapshot details visibility",
      "should snapshot integration",
      "should support multiline text",
      "should concatenate span text",
      "should concatenate span text 2",
      "should concatenate div text with spaces",
      "should include pseudo in text",
      "should not include hidden pseudo in text",
      "should include new line for block pseudo",
      "should work with slots",
      "should snapshot inner text",
      "should include pseudo codepoints",
      "check aria-hidden text",
      "should ignore presentation and none roles",
      "should treat input value as text in templates, but not for checkbox/radio/file",
      "should not use on as checkbox value",
      "should respect aria-owns",
      "should be ok with circular ownership",
      "should escape yaml text in text nodes",
      "should normalize whitespace",
      "should handle long strings",
      "should escape special yaml characters",
      "should escape special yaml values",
      "should not report textarea textContent",
      "should not show visible children of hidden elements",
      "should not show unhidden children of aria-hidden elements",
      "should snapshot placeholder when different from the name",
      "match values both against regex and string"
    ]
  },
  "page/page-autowaiting-basic.spec.ts": {
    "failing": [
      "should await navigation when clicking anchor",
      "should not stall on JS navigation link",
      "should await cross-process navigation when clicking anchor",
      "should await form-get on click",
      "should await form-post on click",
      "should work with noWaitAfter: true",
      "should work with dblclick without noWaitAfter when navigation is stalled",
      "should work with waitForLoadState(load)",
      "should work with goto following click",
      "should report navigation in the log when clicking anchor",
      "should report and collapse log in action",
      "should report and collapse log in expect"
    ]
  },
  "page/page-autowaiting-no-hang.spec.ts": {
    "failing": [
      "clicking on links which do not commit navigation",
      "calling window.stop async",
      "calling window.stop sync",
      "assigning location to about:blank",
      "assigning location to about:blank after non-about:blank",
      "calling window.open and window.close",
      "opening a popup",
      "clicking in the middle of navigation that aborts",
      "clicking in the middle of navigation that commits",
      "goBack in the middle of navigation that commits"
    ]
  },
  "page/page-basic.spec.ts": {
    "failing": [
      "should fire load when expected",
      "async stacks should work",
      "should provide access to the opener page",
      "should fire domcontentloaded when expected",
      "should pass self as argument to domcontentloaded event",
      "should pass self as argument to load event",
      "page.url should work",
      "page.url should include hashes",
      "page.title should return the page title",
      "page.close should work with window.close",
      "page.frame should respect name",
      "page.frame should respect url",
      "should have sane user agent",
      "page.press should work",
      "page.press should work for Enter",
      "frame.press should work",
      "has navigator.webdriver set to true",
      "should iterate over page properties"
    ]
  },
  "page/page-check.spec.ts": {
    "failing": [
      "should check the box @smoke",
      "should not check the checked box",
      "should uncheck the box",
      "should not uncheck the unchecked box",
      "should check radio",
      "should check radio by aria role",
      "should uncheck radio by aria role",
      "should check the box by aria role",
      "should uncheck the box by aria role",
      "should throw when not a checkbox",
      "should throw when not a checkbox 2",
      "should check the box inside a button",
      "should check the label with position",
      "trial run should not check",
      "trial run should not uncheck",
      "should check the box using setChecked",
      "should throw when trying to uncheck radio button"
    ]
  },
  "page/page-click-during-navigation.spec.ts": {
    "failing": [
      "should not fail with internal error upon navigation"
    ]
  },
  "page/page-click-react.spec.ts": {
    "failing": [
      "should timeout when click opens alert",
      "should not retarget when element changes on hover",
      "should not retarget when element is recycled on hover"
    ]
  },
  "page/page-click-scroll.spec.ts": {
    "failing": [
      "should not hit scroll bar",
      "should scroll into view display:contents",
      "should scroll into view display:contents with a child",
      "should scroll into view display:contents with position",
      "should not crash when force-clicking hidden input",
      "should scroll into view span element",
      "should scroll into view element in iframe"
    ]
  },
  "page/page-click-timeout-1.spec.ts": {
    "failing": [
      "should avoid side effects after timeout",
      "should timeout waiting for button to be enabled"
    ]
  },
  "page/page-click-timeout-2.spec.ts": {
    "failing": [
      "should timeout waiting for display:none to be gone",
      "should timeout waiting for visibility:hidden to be gone"
    ]
  },
  "page/page-click-timeout-3.spec.ts": {
    "failing": [
      "should fail when element jumps during hit testing",
      "should timeout waiting for hit target",
      "should still click when force but hit target is obscured",
      "should report wrong hit target subtree"
    ]
  },
  "page/page-click-timeout-4.spec.ts": {
    "failing": [
      "should timeout waiting for stable position",
      "should click for the second time after first timeout",
      "should fail to click the button behind a large header after scrolling around"
    ]
  },
  "page/page-click.spec.ts": {
    "failing": [
      "should click the button @smoke",
      "should click button inside frameset",
      "should issue clicks in parallel in page and popup",
      "should click svg",
      "should click the button if window.Node is removed",
      "should click on a span with an inline element inside",
      "should click the aligned 1x1 div",
      "should click the half-aligned 1x1 div",
      "should click the unaligned 1x1 div v1",
      "should click the unaligned 1x1 div v2",
      "should click the unaligned 1x1 div v3",
      "should click the unaligned 1x1 div v4",
      "should click the button after navigation ",
      "should click the button after a cross origin navigation ",
      "should click when one of inline box children is outside of viewport",
      "should select the text by triple clicking",
      "should click offscreen buttons",
      "should waitFor visible when already visible",
      "should not wait with force",
      "should waitFor display:none to be gone",
      "should waitFor visibility:hidden to be gone",
      "should waitFor visible when parent is hidden",
      "should click wrapped links",
      "should click on checkbox input and toggle",
      "should click on checkbox label and toggle",
      "should scroll and click the button",
      "should scroll and click the button with smooth scroll behavior",
      "should double click the button",
      "should click a partially obscured button",
      "should click a rotated button",
      "should fire contextmenu event on right click",
      "should click links which cause navigation",
      "should click the button inside an iframe",
      "should click the button with fixed position inside an iframe",
      "should click the button behind sticky header",
      "should click the button behind position:absolute header",
      "should click the button with px border with offset",
      "should click the button with em border with offset",
      "should click a very large button with offset",
      "should click a button in scrolling container with offset",
      "should wait for stable position",
      "should wait for becoming hit target",
      "should wait for becoming hit target with trial run",
      "trial run should work with short timeout",
      "trial run should not click",
      "trial run should not double click",
      "should fail when obscured and not waiting for hit target",
      "should wait for button to be enabled",
      "should wait for input to be enabled",
      "should wait for select to be enabled",
      "should click disabled div",
      "should wait for BUTTON to be clickable when it has pointer-events:none",
      "should wait for LABEL to be clickable when it has pointer-events:none",
      "should update modifiers correctly",
      "should click an offscreen element when scroll-behavior is smooth",
      "should report nice error when element is detached and force-clicked",
      "should fail when element detaches after animation",
      "should retry when element detaches after animation",
      "should retry when element is animating from outside the viewport",
      "should fail when element is animating from outside the viewport with force",
      "should dispatch microtasks in order",
      "should click the button when window.innerWidth is corrupted",
      "should click zero-sized input by label",
      "should not throw protocol error when navigating during the click",
      "should retry when navigating during the click",
      "should not hang when frame is detached",
      "should climb dom for inner label with pointer-events:none",
      "should climb up to [role=button]",
      "should climb up to a anchor",
      "should climb up to a [role=link]",
      "should click in an iframe with border",
      "should click in an iframe with border 2",
      "should click in a transformed iframe",
      "should click a button that is overlaid by a permission popup",
      "should click in a transformed iframe with force",
      "should click in a nested transformed iframe",
      "ensure events are dispatched in the individual tasks",
      "should click if opened select covers the button",
      "should fire contextmenu event on right click in correct order",
      "should set PointerEvent.pressure on pointerdown",
      "should set PointerEvent.pressure on pointermove",
      "should click into shadow root with slotted div",
      "should click shadow root button",
      "should click with tweened mouse movement",
      "should not wait with noAutoWaiting",
      "should not wait with noAutoWaiting 2",
      "should not wait with noAutoWaiting 3"
    ]
  },
  "page/page-dialog.spec.ts": {
    "failing": [
      "should fire",
      "should allow accepting prompts @smoke",
      "should dismiss the prompt",
      "should accept the confirm prompt",
      "should dismiss the confirm prompt",
      "should be able to close context with open alert",
      "should handle multiple alerts",
      "should handle multiple confirms",
      "should auto-dismiss the prompt without listeners",
      "should auto-dismiss the alert without listeners"
    ]
  },
  "page/page-dispatchevent.spec.ts": {
    "failing": [
      "should dispatch click event @smoke",
      "should dispatch click event properties",
      "should dispatch click svg",
      "should dispatch click on a span with an inline element inside",
      "should dispatch click after navigation ",
      "should dispatch click after a cross origin navigation ",
      "should not fail when element is blocked on hover",
      "should dispatch click when node is added in shadow dom",
      "should be atomic",
      "should dispatch drag drop events",
      "should dispatch drag drop events via ElementHandles",
      "should dispatch click event via ElementHandles",
      "should dispatch wheel event",
      "should dispatch device orientation event",
      "should dispatch absolute device orientation event",
      "should dispatch device motion event",
      "should throw if argument is from different frame"
    ]
  },
  "page/page-drag.spec.ts": {
    "failing": [
      "Drag and drop > should work @smoke"
    ],
    "skipped": [
      "should work if not doing a drag",
      "should report event.buttons",
      "should handle custom dataTransfer",
      "what happens when dragging element is destroyed",
      "Drag and drop > should send the right events",
      "Drag and drop > should not send dragover on the first mousemove",
      "Drag and drop > should work inside iframe",
      "Drag and drop > should cancel on escape",
      "Drag and drop > should respect the drop effect",
      "Drag and drop > should work if the drag is canceled",
      "Drag and drop > should work if the drag event is captured but not canceled",
      "Drag and drop > should be able to drag the mouse in a frame",
      "Drag and drop > should work if a frame is stalled",
      "Drag and drop > should work with the helper method",
      "Drag and drop > should allow specifying the position",
      "Drag and drop > should work with locators",
      "Drag and drop > iframe > should drag into an iframe",
      "Drag and drop > iframe > should drag out of an iframe",
      "Drag and drop > should dragAndDrop with tweened mouse movement",
      "Drag and drop > should dragTo with tweened mouse movement"
    ]
  },
  "page/page-emulate-media.spec.ts": {
    "failing": [
      "should emulate type @smoke",
      "should throw in case of bad media argument",
      "should emulate colorScheme should work @smoke",
      "should default to light",
      "should throw in case of bad colorScheme argument",
      "should work during navigation",
      "should change the actual colors in css",
      "should emulate reduced motion",
      "should keep reduced motion and color emulation after reload",
      "should emulate forcedColors ",
      "should emulate contrast "
    ]
  },
  "page/page-evaluate-handle.spec.ts": {
    "failing": [
      "should work",
      "should accept object handle as an argument",
      "should accept object handle to primitive types",
      "should accept nested handle",
      "should accept nested window handle",
      "should accept multiple nested handles",
      "should accept same handle multiple times",
      "should accept same nested object multiple times",
      "should accept object handle to unserializable value",
      "should pass configurable args",
      "should work with primitives"
    ]
  },
  "page/page-evaluate-no-stall.spec.ts": {
    "failing": [
      "should work",
      "should throw while pending navigation",
      "should throw when no main execution context"
    ]
  },
  "page/page-evaluate.spec.ts": {
    "failing": [
      "should work @smoke",
      "should transfer NaN",
      "should transfer -0",
      "should transfer Infinity",
      "should transfer -Infinity",
      "should roundtrip unserializable values",
      "should roundtrip promise to value",
      "should roundtrip promise to unserializable values",
      "should transfer arrays",
      "should transfer arrays as arrays, not objects",
      "should transfer typed arrays",
      "should transfer bigint",
      "should transfer maps as empty objects",
      "should modify global environment",
      "should evaluate in the page context",
      "should return undefined for objects with symbols",
      "should work with function shorthands",
      "should work with unicode chars",
      "should work with large strings",
      "should work with large unicode strings",
      "should throw when evaluation triggers reload",
      "should await promise",
      "should work right after framenavigated",
      "should work right after a cross-origin navigation",
      "should work from-inside an exposed function",
      "should reject promise with exception",
      "should support thrown strings as error messages",
      "should support thrown numbers as error messages",
      "should return complex objects",
      "should return NaN",
      "should return -0",
      "should return Infinity",
      "should return -Infinity",
      "should work with overwritten Promise",
      "should throw when passed more than one parameter",
      "should accept \"undefined\" as one of multiple parameters",
      "should properly serialize undefined arguments",
      "should properly serialize undefined fields",
      "should return undefined properties",
      "should properly serialize null arguments",
      "should properly serialize null fields",
      "should properly serialize PerformanceMeasure object",
      "should properly serialize window.performance object",
      "should return undefined for non-serializable objects",
      "should throw for too deep reference chain",
      "should throw usable message for unserializable shallow function",
      "should throw usable message for unserializable object one deep function",
      "should throw usable message for unserializable object nested function",
      "should throw usable message for unserializable array nested function",
      "should alias Window, Document and Node",
      "should work for circular object",
      "should be able to throw a tricky error",
      "should accept a string",
      "should accept a string with semi colons",
      "should accept a string with comments",
      "should accept element handle as an argument",
      "should throw if underlying element was disposed",
      "should simulate a user gesture",
      "should throw a nice error after a navigation",
      "should not throw an error when evaluation does a navigation",
      "should not throw an error when evaluation does a synchronous navigation and returns an object",
      "should not throw an error when evaluation does a synchronous navigation and returns undefined",
      "should transfer 100Mb of data from page to node.js",
      "should throw error with detailed information on exception inside promise ",
      "should work even when JSON is set to null",
      "should await promise from popup",
      "should work with new Function() and CSP",
      "should work with non-strict expressions",
      "should respect use strict expression",
      "should not leak utility script",
      "should not leak handles",
      "should work with CSP",
      "should evaluate exception with a function on the stack",
      "should evaluate exception",
      "should pass exception argument",
      "should evaluate date",
      "should roundtrip date",
      "should roundtrip regex",
      "should jsonValue() date",
      "should evaluate url",
      "should roundtrip url",
      "should jsonValue() url",
      "should not use toJSON when evaluating",
      "should not use Array.prototype.toJSON when evaluating",
      "should not add a toJSON property to newly created Arrays after evaluation",
      "should not use toJSON in jsonValue",
      "should ignore buggy toJSON",
      "should not expose the injected script export",
      "should throw when frame is detached",
      "should work with overridden Object.defineProperty",
      "should work with busted Array.prototype.map/push",
      "should work with overridden globalThis.Window/Document/Node",
      "should work with overridden URL/Date/RegExp",
      "should work with Array.from/map",
      "should ignore dangerous object keys",
      "should allow calling _evaluateFunction"
    ]
  },
  "page/page-event-console.spec.ts": {
    "failing": [
      "should work @smoke",
      "should emit same log twice",
      "should use text() for inspection",
      "should work for different console API calls",
      "should format the message correctly with time/timeLog/timeEnd",
      "should not fail for window object",
      "should trigger correct Log",
      "should have location for console API calls",
      "should not throw when there are console messages in detached iframes",
      "should use object previews for arrays and objects",
      "should use object previews for errors",
      "do not update console count on unhandled rejections",
      "consoleMessages should work"
    ]
  },
  "page/page-event-load.spec.ts": {
    "failing": [
      "should fire once",
      "should fire once with iframe navigation"
    ]
  },
  "page/page-event-network.spec.ts": {
    "failing": [
      "Page.Events.Request @smoke",
      "Page.Events.Response @smoke",
      "Page.Events.RequestFailed @smoke",
      "Page.Events.RequestFinished @smoke",
      "should fire events in proper order",
      "should support redirects",
      "should resolve responses after a navigation"
    ]
  },
  "page/page-event-pageerror.spec.ts": {
    "failing": [
      "should fire",
      "should not receive console message for pageError",
      "should contain sourceURL",
      "should contain the Error.name property",
      "should support an empty Error.name property",
      "should handle odd values",
      "should handle object",
      "should handle window",
      "should remove a listener of a non-existing event handler",
      "should emit error from unhandled rejects",
      "pageErrors should work",
      "should fire illegal character error"
    ]
  },
  "page/page-event-popup.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with window features",
      "should emit for immediately closed popups",
      "should emit for immediately closed popups 2",
      "should be able to capture alert",
      "should work with empty url",
      "should work with noopener and no url",
      "should work with noopener and about:blank",
      "should work with noopener and url",
      "should work with clicking target=_blank",
      "should work with fake-clicking target=_blank and rel=noopener",
      "should work with clicking target=_blank and rel=noopener",
      "should report popup opened from iframes"
    ]
  },
  "page/page-event-request.spec.ts": {
    "failing": [
      "should fire for navigation requests",
      "should fire for iframes",
      "should fire for fetches",
      "should fire for fetches with keepalive: true",
      "should report requests and responses handled by service worker",
      "should report requests and responses handled by service worker with routing",
      "should report navigation requests and responses handled by service worker",
      "should report navigation requests and responses handled by service worker with routing",
      "should return response body when Cross-Origin-Opener-Policy is set",
      "should fire requestfailed when intercepting race",
      "main resource xhr should have type xhr",
      "should finish 204 request",
      "<picture> resource should have type image",
      "should not expose preflight OPTIONS request",
      "should not expose preflight OPTIONS request with network interception",
      "should return last requests"
    ]
  },
  "page/page-expose-function.spec.ts": {
    "failing": [
      "exposeBinding should work @smoke",
      "should work",
      "should work with handles and complex objects",
      "should throw exception in page context",
      "should support throwing \"null\"",
      "should be callable from-inside addInitScript",
      "should survive navigation",
      "should await returned promise",
      "should work on frames",
      "should work on frames before navigation",
      "should work after cross origin navigation",
      "should work with complex objects",
      "exposeBindingHandle should work",
      "exposeBindingHandle should not throw during navigation",
      "should throw for duplicate registrations",
      "exposeBindingHandle should throw for multiple arguments",
      "exposeBinding(handle) should work with element handles",
      "should work with setContent",
      "should alias Window, Document and Node",
      "should serialize cycles",
      "should work with overridden console object",
      "should work with busted Array.prototype.map/push",
      "should fail with busted Array.prototype.toJSON",
      "exposeBinding should work in parallel"
    ]
  },
  "page/page-filechooser.spec.ts": {
    "failing": [
      "should upload multiple large files",
      "should emit event once",
      "should emit event via prepend",
      "should emit event for iframe",
      "should emit event on/off",
      "should emit event addListener/removeListener",
      "should work when file input is attached to DOM",
      "should work when file input is not attached to DOM",
      "should not throw when filechooser belongs to iframe",
      "should not throw when frame is detached immediately",
      "should respect timeout",
      "should respect default timeout when there is no custom timeout",
      "should prioritize exact timeout over default timeout",
      "should work with no timeout",
      "should return the same file chooser when there are many watchdogs simultaneously",
      "should accept single file",
      "should not trim big uploaded files",
      "should be able to read selected file",
      "should be able to reset selected files with empty file list",
      "should work for single file pick",
      "should work for \"multiple\"",
      "should work for \"webkitdirectory\"",
      "should emit event after navigation",
      "should trigger listener added before navigation"
    ]
  },
  "page/page-fill.spec.ts": {
    "failing": [
      "should fill textarea @smoke",
      "should fill input",
      "should throw on unsupported inputs",
      "should fill different input types",
      "should fill range input",
      "should throw on incorrect range value",
      "should fill color input",
      "should throw on incorrect color value",
      "should fill date input after clicking",
      "input event.composed should be true and cross shadow dom boundary - color",
      "input event.composed should be true and cross shadow dom boundary - date",
      "input event.composed should be true and cross shadow dom boundary - time",
      "input event.composed should be true and cross shadow dom boundary - datetime-local",
      "input event.composed should be true and cross shadow dom boundary - month",
      "input event.composed should be true and cross shadow dom boundary - range",
      "input event.composed should be true and cross shadow dom boundary - week",
      "should throw on incorrect date",
      "should fill time input",
      "should fill month input",
      "should throw on incorrect month",
      "should fill week input",
      "should throw on incorrect week",
      "should throw on incorrect time",
      "should fill datetime-local input",
      "should throw on incorrect datetime-local",
      "should fill contenteditable",
      "should fill contenteditable with new lines",
      "should not double-fill in contenteditable with beforeinput handler in Firefox",
      "should fill elements with existing value and selection",
      "should throw nice error without injected script stack when element is not an <input>",
      "should throw if passed a non-string value",
      "should retry on disabled element",
      "should retry on readonly element",
      "should retry on invisible element",
      "should be able to fill the body",
      "should fill fixed position input",
      "should be able to fill when focus is in the wrong frame",
      "should be able to fill the input[type=number]",
      "should be able to fill exponent into the input[type=number]",
      "should be able to fill input[type=number] with empty string",
      "should not be able to fill text into the input[type=number]",
      "should be able to clear using fill()",
      "should not throw when fill causes navigation",
      "fill back to back",
      "should fill color input case insensitive"
    ]
  },
  "page/page-focus.spec.ts": {
    "failing": [
      "should work @smoke",
      "should emit focus event",
      "should emit blur event",
      "should traverse focus",
      "should traverse focus in all directions",
      "should traverse only form elements",
      "clicking checkbox should activate it",
      "tab should cycle between single input and browser",
      "tab should cycle between document elements and browser",
      "keeps focus on element when attempting to focus a non-focusable element"
    ]
  },
  "page/page-goto.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with file URL",
      "should work with file URL with subframes",
      "should use http for no protocol",
      "should work cross-process",
      "should work with cross-process that fails before committing",
      "should work with Cross-Origin-Opener-Policy",
      "should work with Cross-Origin-Opener-Policy and interception",
      "should work with Cross-Origin-Opener-Policy after redirect",
      "should capture iframe navigation request",
      "should capture cross-process iframe navigation request",
      "should work with anchor navigation",
      "should work with redirects",
      "should navigate to about:blank",
      "should return response when page changes its URL after load",
      "should work with subframes return 204",
      "should work with subframes return 204 with domcontentloaded",
      "should fail when server returns 204",
      "should navigate to empty page with domcontentloaded",
      "should work when page calls history API in beforeunload",
      "should fail when navigating to bad url",
      "should fail when navigating to bad SSL",
      "should fail when navigating to bad SSL after redirects",
      "should not crash when navigating to bad SSL after a cross origin navigation",
      "should not throw if networkidle0 is passed as an option",
      "should throw if networkidle2 is passed as an option",
      "should fail when main resources failed to load",
      "should fail when exceeding maximum navigation timeout",
      "should fail when exceeding default maximum navigation timeout",
      "should fail when exceeding browser context navigation timeout",
      "should fail when exceeding default maximum timeout",
      "should fail when exceeding browser context timeout",
      "should prioritize default navigation timeout over default timeout",
      "should disable timeout when its set to 0",
      "should fail when replaced by another navigation",
      "js redirect overrides url bar navigation ",
      "should succeed on url bar navigation when there is pending navigation",
      "should work when navigating to valid url",
      "should work when navigating to data url",
      "should work when navigating to 404",
      "should return last response in redirect chain",
      "should not leak listeners during navigation",
      "should not leak listeners during bad navigation",
      "should not leak listeners during 20 waitForNavigation",
      "should navigate to dataURL and not fire dataURL requests",
      "should navigate to URL with hash and fire requests without hash",
      "should work with self requesting page",
      "should fail when navigating and show the url at the error message",
      "should be able to navigate to a page controlled by service worker",
      "should send referer",
      "should send referer of cross-origin URL",
      "should reject referer option when setExtraHTTPHeaders provides referer",
      "should override referrer-policy",
      "should fail when canceled by another navigation",
      "should work with lazy loading iframes",
      "should report raw buffer for main resource",
      "should not throw unhandled rejections on invalid url",
      "should not crash when RTCPeerConnection is used",
      "should properly wait for load",
      "should not resolve goto upon window.stop()",
      "should return from goto if new navigation is started",
      "should return when navigation is committed if commit is specified",
      "should wait for load when iframe attaches and detaches",
      "should return url with basic auth info"
    ]
  },
  "page/page-history.spec.ts": {
    "failing": [
      "page.goBack should work @smoke",
      "page.goBack should work with HistoryAPI",
      "page.goBack should work for file urls",
      "goBack/goForward should work with bfcache-able pages",
      "page.reload should work",
      "page.reload should work with data url",
      "page.reload during renderer-initiated navigation",
      "page.reload should not resolve with same-document navigation",
      "page.reload should work with same origin redirect",
      "page.reload should work with cross-origin redirect",
      "page.reload should work on a page with a hash",
      "page.reload should work on a page with a hash at the end",
      "page.goBack during renderer-initiated navigation",
      "page.goForward during renderer-initiated navigation",
      "regression test for issue 20791",
      "should reload proper page"
    ]
  },
  "page/page-keyboard.spec.ts": {
    "failing": [
      "should type into a textarea @smoke",
      "should move with the arrow keys",
      "should send a character with ElementHandle.press",
      "should send a character with insertText",
      "insertText should only emit input event",
      "should report shiftKey",
      "should report multiple modifiers",
      "should send proper codes while typing",
      "should send proper codes while typing with shift",
      "should not type canceled events",
      "should press plus",
      "should press shift plus",
      "should support plus-separated modifiers",
      "should support multiple plus-separated modifiers",
      "should shift raw codes",
      "should specify repeat property",
      "should type all kinds of characters",
      "should specify location",
      "should press Enter",
      "should throw on unknown keys",
      "should type emoji",
      "should type emoji into an iframe",
      "should handle selectAll",
      "pressing Meta should not result in any text insertion on any platform",
      "should be able to prevent selectAll",
      "should support MacOS shortcuts",
      "should press the meta key",
      "should work with keyboard events with empty.html",
      "should work after a cross origin navigation",
      "should expose keyIdentifier in webkit",
      "should scroll with PageDown",
      "should move around the selection in a contenteditable",
      "should move to the start of the document",
      "should dispatch a click event on a button when Space gets pressed",
      "should dispatch a click event on a button when Enter gets pressed",
      "should support simple copy-pasting",
      "should support simple cut-pasting",
      "should support undo-redo",
      "should type repeatedly in contenteditable in shadow dom",
      "should type repeatedly in contenteditable in shadow dom with nested elements",
      "should type repeatedly in input in shadow dom",
      "type to non-focusable element should maintain old focus",
      "should dispatch insertText after context menu was opened",
      "should type after context menu was opened",
      "should have correct Keydown/Keyup order when pressing Escape key",
      "should close dialog on Escape key press in contenteditable"
    ]
  },
  "page/page-listeners.spec.ts": {
    "failing": [
      "should not throw with ignoreErrors",
      "should wait",
      "wait should throw"
    ]
  },
  "page/page-mouse.spec.ts": {
    "failing": [
      "should click the document @smoke",
      "should dblclick the div",
      "down and up should generate click",
      "should pointerdown the div with a custom button",
      "should report correct buttons property",
      "should select the text with mouse",
      "should trigger hover state",
      "should trigger hover state on disabled button",
      "should trigger hover state with removed window.Node",
      "should set modifier keys on click",
      "should tween mouse movement",
      "should always round down",
      "should not crash on mouse drag with any button",
      "should dispatch mouse move after context menu was opened",
      "should report correct pointerType property"
    ]
  },
  "page/page-navigation.spec.ts": {
    "failing": [
      "should work with _blank target",
      "should work with cross-process _blank target",
      "should work with _blank target in form"
    ]
  },
  "page/page-network-idle.spec.ts": {
    "failing": [
      "should navigate to empty page with networkidle",
      "should wait for networkidle to succeed navigation",
      "should wait for networkidle to succeed navigation with request from previous navigation",
      "should wait for networkidle in waitForNavigation",
      "should wait for networkidle in setContent",
      "should wait for networkidle in setContent with request from previous navigation",
      "should wait for networkidle when navigating iframe",
      "should wait for networkidle in setContent from the child frame",
      "should wait for networkidle from the child frame",
      "should wait for networkidle from the popup",
      "should wait for networkidle when iframe attaches and detaches",
      "should work after repeated navigations in the same page"
    ]
  },
  "page/page-network-request.spec.ts": {
    "failing": [
      "should work for main frame navigation request",
      "should work for subframe navigation request",
      "should work for fetch requests @smoke",
      "should work for a redirect",
      "should not work for a redirect and interception",
      "should return headers",
      "should get the same headers as the server",
      "should not return allHeaders() until they are available",
      "should get the same headers as the server CORS",
      "should not get preflight CORS requests when intercepting",
      "should return postData",
      "should work with binary post data",
      "should work with binary post data and interception",
      "should override post data content type",
      "should get |undefined| with postData() when there is no post data",
      "should parse the json post data",
      "should parse the data if content-type is application/x-www-form-urlencoded",
      "should parse the data if content-type is application/x-www-form-urlencoded; charset=UTF-8",
      "should get |undefined| with postDataJSON() when there is no post data",
      "should return multipart/form-data",
      "should return event source",
      "should return navigation bit",
      "should return navigation bit when navigating to image",
      "should report raw headers",
      "should report raw response headers in redirects",
      "should report all cookies in one header",
      "should not allow to access frame on popup main request",
      "page.reload return 304 status code",
      "should handle mixed-content blocked requests"
    ]
  },
  "page/page-network-response.spec.ts": {
    "failing": [
      "should work @smoke",
      "should return multiple header value",
      "should return text",
      "should return uncompressed text",
      "should throw when requesting body of redirected response",
      "should wait until response completes",
      "should return json",
      "should return body",
      "should return body with compression",
      "should return status text",
      "should report all headers",
      "should report multiple set-cookie headers",
      "should behave the same way for headers and allHeaders",
      "should provide a Response with a file URL",
      "should return set-cookie header after route.fulfill",
      "should return headers after route.fulfill",
      "should report if request was fromServiceWorker",
      "should return body for prefetch script",
      "should bypass disk cache when page interception is enabled",
      "should bypass disk cache when context interception is enabled"
    ]
  },
  "page/page-network-sizes.spec.ts": {
    "failing": [
      "should set bodySize and headersSize"
    ],
    "skipped": [
      "should set bodySize to 0 if there was no body",
      "should set bodySize, headersSize, and transferSize",
      "should set bodySize to 0 when there was no response body",
      "should have the correct responseBodySize",
      "should have the correct responseBodySize for chunked request",
      "should have the correct responseBodySize with gzip compression",
      "should handle redirects",
      "should throw for failed requests",
      "should work with 200 status code",
      "should work with 401 status code",
      "should work with 404 status code",
      "should work with 500 status code",
      "should have correct responseBodySize for 404 with content",
      "should return sizes without hanging"
    ]
  },
  "page/page-request-continue.spec.ts": {
    "failing": [
      "should work",
      "should amend HTTP headers",
      "should not allow to override unsafe HTTP headers",
      "should delete header with undefined value",
      "should amend method",
      "should override request url",
      "should not allow changing protocol when overriding url",
      "should not throw if request was cancelled by the page",
      "should override method along with url",
      "should amend method on main request",
      "should work with Cross-Origin-Opener-Policy",
      "should continue preload link requests",
      "should respect set-cookie in redirect response",
      "continue should not propagate cookie override to redirects",
      "continue should not override cookie",
      "redirect after continue should be able to delete cookie",
      "continue should propagate headers to redirects",
      "continue should drop content-length on redirects",
      "redirected requests should report overridden headers",
      "continue should delete headers on redirects",
      "propagate headers same origin redirect",
      "propagate headers cross origin",
      "propagate headers cross origin redirect",
      "propagate headers cross origin redirect after interception",
      "should intercept css variable with background url",
      "continue should not change multipart/form-data body",
      "should not forward Host header on cross-origin redirect",
      "post data > should amend post data",
      "post data > should compute content-length from post data",
      "post data > should amend method and post data",
      "post data > should amend utf8 post data",
      "post data > should amend longer post data",
      "post data > should amend binary post data",
      "post data > should use content-type from original request",
      "should not delete the origin header"
    ]
  },
  "page/page-request-fallback.spec.ts": {
    "failing": [
      "should work",
      "should fall back",
      "should fall back async",
      "should not chain fulfill",
      "should not chain abort",
      "should fall back after exception",
      "should chain once",
      "should amend HTTP headers",
      "should delete header with undefined value",
      "should amend method",
      "should override request url",
      "post data > should amend post data",
      "post data > should amend binary post data",
      "post data > should amend json post data"
    ]
  },
  "page/page-request-fulfill.spec.ts": {
    "failing": [
      "should work",
      "should work with buffer as body",
      "should work with status code 422",
      "should fulfill with unuassigned status codes",
      "should not throw if request was cancelled by the page",
      "should allow mocking binary responses",
      "should allow mocking svg with charset",
      "should work with file path",
      "should stringify intercepted request response headers",
      "should not modify the headers sent to the server",
      "should include the origin header",
      "should fulfill with global fetch result",
      "should fulfill with fetch result",
      "should fulfill with fetch result and overrides",
      "should fetch original request and fulfill",
      "should fulfill with multiple set-cookie",
      "should fulfill with fetch response that has multiple set-cookie",
      "headerValue should return set-cookie from intercepted response",
      "should fulfill with har response",
      "should fulfill preload link requests",
      "should fulfill json",
      "should fulfill with gzip and readback",
      "should not go to the network for fulfilled requests body",
      "should return body for fulfilled responses"
    ]
  },
  "page/page-request-gc.spec.ts": {
    "failing": [
      "should work"
    ]
  },
  "page/page-request-intercept.spec.ts": {
    "failing": [
      "should fulfill intercepted response",
      "should fulfill response with empty body",
      "should override with defaults when intercepted response not provided",
      "should fulfill with any response",
      "should support fulfill after intercept",
      "should give access to the intercepted response",
      "should give access to the intercepted response body",
      "should intercept multipart/form-data request body",
      "should fulfill intercepted response using alias",
      "should support timeout option in route.fetch",
      "should not follow redirects when maxRedirects is set to 0 in route.fetch",
      "should intercept with url override",
      "should intercept with post data override",
      "should fulfill popup main request using alias",
      "request.postData is not null when fetching FormData with a Blob",
      "should abort favicon requests if interception is enabled"
    ]
  },
  "page/page-route.spec.ts": {
    "failing": [
      "should intercept @smoke",
      "should unroute",
      "should not support ? in glob pattern",
      "should work when POST is redirected with 302",
      "should work when header manipulation headers with redirect",
      "should be able to remove headers",
      "should contain referer header",
      "should properly return navigation response when URL has cookies",
      "should not override cookie header",
      "should show custom HTTP headers",
      "should work with redirect inside sync XHR",
      "should pause intercepted XHR until continue",
      "should pause intercepted fetch request until continue",
      "should work with custom referer headers",
      "should be abortable",
      "should be abortable with custom error codes",
      "should not throw if request was cancelled by the page",
      "should send referer",
      "should fail navigation when aborting main resource",
      "should not work with redirects",
      "should chain fallback w/ dynamic URL",
      "should work with redirects for subresources",
      "should work with equal requests",
      "should navigate to dataURL and not fire dataURL requests",
      "should be able to fetch dataURL and not fire dataURL requests",
      "should navigate to URL with hash and and fire requests without hash",
      "should work with encoded server",
      "should work with badly encoded server",
      "should work with encoded server - 2",
      "should not throw \"Invalid Interception Id\" if the request was cancelled",
      "should intercept main resource during cross-process navigation",
      "should fulfill with redirect status",
      "should not fulfill with redirect status",
      "should support cors with GET",
      "should add Access-Control-Allow-Origin by default when fulfill",
      "should allow null origin for about:blank",
      "should respect cors overrides",
      "should not auto-intercept non-preflight OPTIONS without network interception",
      "should not auto-intercept non-preflight OPTIONS with network interception",
      "should support cors with POST",
      "should support cors with credentials",
      "should reject cors with disallowed credentials",
      "should support cors for different methods",
      "should support the times parameter with route matching",
      "should work if handler with times parameter was removed from another handler",
      "should support async handler w/ times",
      "should contain raw request header",
      "should contain raw response header",
      "should contain raw response header after fulfill",
      "route.fulfill should throw if called twice",
      "route.continue should throw if called twice",
      "route.fallback should throw if called twice",
      "route.abort should throw if called twice",
      "should intercept when postData is more than 1MB",
      "should be able to intercept every navigation to a page controlled by service worker",
      "does not get stalled by beforeUnload"
    ]
  },
  "page/page-screenshot.spec.ts": {
    "failing": [
      "should throw if screenshot size is too large",
      "page screenshot should capture css transform",
      "should capture css box-shadow",
      "page screenshot > should work @smoke",
      "page screenshot > should not capture blinking caret by default",
      "page screenshot > should capture blinking caret if explicitly asked for",
      "page screenshot > should capture blinking caret in shadow dom",
      "page screenshot > should clip rect",
      "page screenshot > should clip rect with fullPage",
      "page screenshot > should clip elements to the viewport",
      "page screenshot > should throw on clip outside the viewport",
      "page screenshot > should run in parallel",
      "page screenshot > should take fullPage screenshots",
      "page screenshot > should take fullPage screenshots and mask elements outside of it",
      "page screenshot > should restore viewport after fullPage screenshot",
      "page screenshot > should allow transparency",
      "page screenshot > should render white background on jpeg file",
      "page screenshot > should work with odd clip size on Retina displays",
      "page screenshot > should work for canvas",
      "page screenshot > should capture canvas changes",
      "page screenshot > should work for webgl",
      "page screenshot > should work for translateZ",
      "page screenshot > should work while navigating",
      "page screenshot > should work with iframe in shadow",
      "page screenshot > path option should work",
      "page screenshot > path option should create subdirectories",
      "page screenshot > path option should detect jpeg",
      "page screenshot > path option should throw for unsupported mime type",
      "page screenshot > quality option should throw for png",
      "page screenshot > zero quality option should throw for png",
      "page screenshot > should prefer type over extension",
      "page screenshot > should not issue resize event",
      "page screenshot > should work with Array deleted",
      "page screenshot > should take fullPage screenshots during navigation",
      "page screenshot > mask option > should work",
      "page screenshot > mask option > should work with locator",
      "page screenshot > mask option > should work with elementhandle",
      "page screenshot > mask option > should mask multiple elements",
      "page screenshot > mask option > should mask inside iframe",
      "page screenshot > mask option > should mask in parallel",
      "page screenshot > mask option > should remove mask after screenshot",
      "page screenshot > mask option > should work when subframe has stalled navigation",
      "page screenshot > mask option > should work when subframe used document.open after a weird url",
      "page screenshot > mask option > should work when mask color is not pink #F0F",
      "page screenshot > mask option > should hide elements based on attr",
      "page screenshot > mask option > should remove elements based on attr",
      "page screenshot animations > should not capture infinite css animation",
      "page screenshot animations > should not capture pseudo element css animation",
      "page screenshot animations > should not capture css animations in shadow DOM",
      "page screenshot animations > should stop animations that happen right before screenshot",
      "page screenshot animations > should resume infinite animations",
      "page screenshot animations > should not capture infinite web animations",
      "page screenshot animations > should fire transitionend for finite transitions",
      "page screenshot animations > should capture screenshots after layoutchanges in transitionend event",
      "page screenshot animations > should not change animation with playbackRate equal to 0",
      "page screenshot animations > should trigger particular events for css transitions",
      "page screenshot animations > should trigger particular events for INfinite css animation",
      "page screenshot animations > should trigger particular events for finite css animation",
      "page screenshot animations > should wait for fonts to load"
    ]
  },
  "page/page-select-option.spec.ts": {
    "failing": [
      "should select single option @smoke",
      "should select single option by value",
      "should fall back to selecting by label",
      "should select single option by label",
      "should select single option by handle",
      "should select single option by index",
      "should select single option by multiple attributes",
      "should not select single option when some attributes do not match",
      "should select only first option",
      "should not throw when select causes navigation",
      "should select multiple options",
      "should select multiple options with attributes",
      "should respect event bubbling",
      "should throw when element is not a <select>",
      "should return [] on no matched values",
      "should return an array of matched values",
      "should return an array of one element when multiple is not set",
      "should return [] on no values",
      "should not allow null items",
      "should unselect with null",
      "should deselect all options when passed no values for a multiple select",
      "should deselect all options when passed no values for a select without multiple",
      "should throw if passed wrong types",
      "should work when re-defining top-level Event class",
      "should wait for option to be present",
      "should wait for option index to be present",
      "should wait for multiple options to be present",
      "input event.composed should be true and cross shadow dom boundary",
      "should wait for select to be enabled",
      "should wait for option to be enabled",
      "should wait for optgroup to be enabled",
      "should wait for select to be swapped"
    ]
  },
  "page/page-set-content.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with domcontentloaded",
      "should work with commit",
      "should work with doctype",
      "should work with HTML 4 doctype",
      "should respect timeout",
      "should respect default navigation timeout",
      "should await resources to load",
      "should work fast enough",
      "should work with tricky content",
      "should work with accents",
      "should work with emojis",
      "should work with newline",
      "content() should throw nice error during navigation",
      "should return empty content there is no iframe src",
      "should handle timeout properly",
      "should handle timeout properly 2"
    ]
  },
  "page/page-set-extra-http-headers.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with redirects",
      "should work with extra headers from browser context",
      "should throw for non-string header values",
      "should not duplicate referer header"
    ]
  },
  "page/page-set-input-files.spec.ts": {
    "failing": [
      "should upload the file",
      "should upload a folder",
      "should upload a folder and throw for multiple directories",
      "should throw if a directory and files are passed",
      "should throw when uploading a folder in a normal file upload input",
      "should throw when uploading a file in a directory upload input",
      "should upload a file after popup",
      "should upload large file",
      "should throw an error if the file does not exist",
      "should upload large file with relative path",
      "should upload the file with spaces in name",
      "should work @smoke",
      "should set from memory",
      "should work with CSP",
      "should detect mime type",
      "should not trim big uploaded files",
      "should emit input and change events",
      "input event.composed should be true and cross shadow dom boundary",
      "input should trigger events when files changed second time",
      "should preserve lastModified timestamp"
    ]
  },
  "page/page-strict.spec.ts": {
    "failing": [
      "should fail page.textContent in strict mode",
      "should fail page.getAttribute in strict mode",
      "should fail page.fill in strict mode",
      "should fail page.$ in strict mode",
      "should fail page.waitForSelector in strict mode",
      "should fail page.dispatchEvent in strict mode",
      "should properly format :nth-child() in strict mode message",
      "should escape class names",
      "should escape tag names"
    ]
  },
  "page/page-wait-for-function.spec.ts": {
    "failing": [
      "should timeout",
      "should accept a string",
      "should work when resolved right before execution context disposal",
      "should poll on interval",
      "should avoid side effects after timeout",
      "should throw on polling:mutation",
      "should poll on raf",
      "should fail with predicate throwing on first call",
      "should fail with predicate throwing sometimes",
      "should fail with ReferenceError on wrong page",
      "should work with strict CSP policy",
      "should throw on bad polling value",
      "should throw negative polling interval",
      "should return the success value as a JSHandle",
      "should return the window as a success value",
      "should accept ElementHandle arguments",
      "should respect timeout",
      "should respect default timeout",
      "should disable timeout when its set to 0",
      "should survive cross-process navigation",
      "should survive navigations",
      "should work with multiline body",
      "should wait for predicate with arguments",
      "should not be called after finishing successfully",
      "should not be called after finishing unsuccessfully",
      "should throw when frame is detached"
    ]
  },
  "page/page-wait-for-load-state.spec.ts": {
    "failing": [
      "should pick up ongoing navigation",
      "should respect timeout",
      "should resolve immediately if loaded",
      "should throw for bad state",
      "should resolve immediately if load state matches",
      "should work with pages that have loaded before being connected to",
      "should wait for load state of empty url popup",
      "should wait for load state of about:blank popup ",
      "should wait for load state of about:blank popup with noopener ",
      "should wait for load state of popup with network url ",
      "should wait for load state of popup with network url and noopener ",
      "should work with clicking target=_blank",
      "should wait for load state of newPage",
      "should resolve after popup load",
      "should work for frame",
      "should work with javascript: iframe",
      "should work with broken data-url iframe",
      "should work with broken blob-url iframe"
    ]
  },
  "page/page-wait-for-navigation.spec.ts": {
    "failing": [
      "should work",
      "should respect timeout",
      "should work with both domcontentloaded and load",
      "should work with commit",
      "should work with clicking on anchor links",
      "should work with clicking on links which do not commit navigation",
      "should work with history.pushState()",
      "should work with history.replaceState()",
      "should work with DOM history.back()/history.forward()",
      "should work when subframe issues window.stop()",
      "should work with url match",
      "should work with url match for same document navigations",
      "should work for cross-process navigations",
      "should work on frame",
      "should fail when frame detaches"
    ]
  },
  "page/page-wait-for-request.spec.ts": {
    "failing": [
      "should work",
      "should work with predicate",
      "should respect timeout",
      "should respect default timeout",
      "should log the url",
      "should work with no timeout",
      "should work with url match",
      "should work with url match regular expression from a different context"
    ]
  },
  "page/page-wait-for-response.spec.ts": {
    "failing": [
      "should work",
      "should respect timeout",
      "should respect default timeout",
      "should log the url",
      "should work with predicate",
      "should work with async predicate",
      "sync predicate should be only called once",
      "should work with no timeout",
      "should work with re-rendered cached IMG elements"
    ]
  },
  "page/page-wait-for-selector-1.spec.ts": {
    "failing": [
      "should throw on waitFor",
      "should tolerate waitFor=visible",
      "should immediately resolve promise if node exists",
      "elementHandle.waitForSelector should immediately resolve if node exists",
      "elementHandle.waitForSelector should wait",
      "elementHandle.waitForSelector should timeout",
      "elementHandle.waitForSelector should throw on navigation",
      "should work with removed MutationObserver",
      "should resolve promise when node is added",
      "should report logs while waiting for visible",
      "should report logs while waiting for hidden",
      "should report logs when the selector resolves to multiple elements",
      "should resolve promise when node is added in shadow dom",
      "should work when node is added through innerHTML",
      "page.waitForSelector is shortcut for main frame",
      "should run in specified frame",
      "should throw when frame is detached"
    ]
  },
  "page/page-wait-for-selector-2.spec.ts": {
    "failing": [
      "should survive cross-process navigation",
      "should wait for visible",
      "should not consider visible when zero-sized",
      "should wait for visible recursively",
      "should consider outside of viewport visible",
      "hidden should wait for hidden",
      "hidden should wait for display: none",
      "hidden should wait for removal",
      "should return null if waiting to hide non-existing element",
      "should respect timeout",
      "should have an error message specifically for awaiting an element to be hidden",
      "should respond to node attribute mutation",
      "should return the element handle",
      "should have correct stack trace for timeout",
      "should throw for unknown state option",
      "should throw for visibility option",
      "should throw for true state option",
      "should throw for false state option",
      "should support >> selector syntax",
      "should wait for detached if already detached",
      "should wait for detached",
      "should support some fancy xpath",
      "should respect timeout xpath",
      "should run in specified frame xpath",
      "should throw when frame is detached xpath",
      "should return the element handle xpath",
      "should allow you to select an element with single slash xpath",
      "should correctly handle hidden shadow host",
      "should work when navigating before node adoption",
      "should fail when navigating while on handle",
      "should fail if element handle was detached while waiting",
      "should succeed if element handle was detached while waiting for hidden",
      "should succeed if element handle was detached while waiting for detached"
    ]
  },
  "page/page-wait-for-url.spec.ts": {
    "failing": [
      "should work",
      "should respect timeout",
      "should work with both domcontentloaded and load",
      "should work with commit",
      "should work with commit and about:blank",
      "should work with clicking on anchor links",
      "should work with history.pushState()",
      "should work with history.replaceState()",
      "should work with DOM history.back()/history.forward()",
      "should work with url match for same document navigations",
      "should work on frame"
    ]
  },
  "page/queryselector.spec.ts": {
    "failing": [
      "should throw for non-string selector",
      "should query existing element with css selector @smoke",
      "should query existing element with text selector",
      "should query existing element with xpath selector",
      "should return null for non-existing element",
      "should auto-detect xpath selector",
      "should auto-detect xpath selector with starting parenthesis",
      "should auto-detect xpath selector starting with ..",
      "should auto-detect text selector",
      "should auto-detect css selector",
      "should support >> syntax",
      "should query existing elements",
      "should return empty array if nothing is found",
      "xpath should query existing element",
      "xpath should return empty array for non-existing element",
      "xpath should return multiple elements",
      "$$ should work with bogus Array.from"
    ]
  },
  "page/retarget.spec.ts": {
    "failing": [
      "element state checks should work as expected for label with zero-sized input",
      "should wait for enclosing disabled button",
      "should wait for enclosing button with a disabled fieldset",
      "should wait for enclosing enabled button",
      "should check the box outside shadow dom label",
      "setInputFiles should work with label",
      "enabled/disabled retargeting",
      "visible/hidden retargeting",
      "editable retargeting",
      "input value retargeting",
      "selection retargeting",
      "select options retargeting",
      "direct actions retargeting",
      "check retargeting",
      "should not retarget anchor into parent label"
    ]
  },
  "page/selectors-css.spec.ts": {
    "failing": [
      "should work with large DOM @smoke",
      "should work for open shadow roots",
      "should work with > combinator and spaces",
      "should work with comma separated list",
      "should keep dom order with comma separated list",
      "should return multiple captures for the same node",
      "should return multiple captures when going up the hierarchy",
      "should work with comma separated list in various positions",
      "should work with comma inside text",
      "should work with attribute selectors",
      "should not match root after >>",
      "should work with numerical id",
      "should work with wrong-case id",
      "should work with *",
      "should work with :nth-child",
      "should work with :nth-child(of) notation with nested functions",
      "should work with :not",
      "should work with ~",
      "should work with +",
      "should work with spaces in :nth-child and :not",
      "should work with :is",
      "should work with :has",
      "should work with :scope",
      "should work with :scope and class",
      "should absolutize relative selectors",
      "css on the handle should be relative",
      "should use light DOM structure for child combinator with slotted content"
    ]
  },
  "page/selectors-frame.spec.ts": {
    "failing": [
      "should work for iframe @smoke",
      "should work for iframe (handle)",
      "should work for nested iframe",
      "should work for nested iframe (handle)",
      "should work for $ and $$",
      "$ should not wait for frame",
      "$$ should not wait for frame",
      "$eval should throw for missing frame",
      "$$eval should throw for missing frame",
      "should work for $ and $$ (handle)",
      "should work for $eval",
      "should work for $eval (handle)",
      "should work for $$eval",
      "should work for $$eval (handle)",
      "should not allow dangling enter-frame",
      "should not allow leading enter-frame",
      "should not allow capturing before enter-frame",
      "should capture after the enter-frame",
      "should click in lazy iframe",
      "waitFor should survive frame reattach",
      "waitForSelector should survive frame reattach (handle)",
      "waitForSelector should survive iframe navigation (handle)",
      "click should survive frame reattach",
      "click should survive iframe navigation",
      "click should survive navigation",
      "should non work for non-frame"
    ]
  },
  "page/selectors-get-by.spec.ts": {
    "failing": [
      "getByTestId should work",
      "getByTestId with custom testId should work",
      "getByTestId should escape id",
      "getByTestId should work for regex",
      "getByText should work",
      "getByLabel should work",
      "getByLabel should work with nested elements",
      "getByLabel should work with multiply-labelled input",
      "getByLabel should work with ancestor label and multiple controls",
      "getByLabel should work with ancestor label and for",
      "getByLabel should work with aria-labelledby",
      "getByLabel should prioritize aria-labelledby over native label",
      "getByLabel should work with aria-label",
      "getByLabel should ignore empty aria-label",
      "getByLabel should prioritize aria-labelledby over aria-label",
      "getByPlaceholder should work",
      "getByAltText should work",
      "getByTitle should work",
      "getBy escaping",
      "getByRole escaping"
    ]
  },
  "page/selectors-misc.spec.ts": {
    "failing": [
      "should work for open shadow roots",
      "should click on links in shadow dom",
      "should work with :visible",
      "should work with >> visible=",
      "should work with >> visible=false",
      "should work with :nth-match",
      "should work with nth=",
      "should work with strict mode and chaining",
      "should work with layout selectors",
      "should escape the scope with >>",
      "xpath should be relative",
      "should work with pipe in xpath",
      "should print original xpath in error",
      "data-testid on the handle should be relative",
      "should properly determine visibility of display:contents elements",
      "should work with internal:has=",
      "should work with internal:has-not=",
      "should work with internal:and=",
      "should work with internal:or=",
      "should work with internal:chain=",
      "chaining should work with large DOM @smoke"
    ]
  },
  "page/selectors-react.spec.ts": {
    "failing": [
      "react15 > should work with single-root elements @smoke",
      "react15 > should work with multi-root elements (fragments)",
      "react15 > should not crash when there is no match",
      "react15 > should compose",
      "react15 > should query by props combinations",
      "react15 > should exact match by props",
      "react15 > should partially match by props",
      "react15 > should support all string operators",
      "react15 > should support regex",
      "react15 > should support truthy querying",
      "react15 > should support nested react trees",
      "react15 > should work with react memo",
      "react15 > should work with multiroot react",
      "react15 > should work with multiroot react inside shadow DOM",
      "react15 > should work with multiroot react after unmount",
      "react16 > should work with single-root elements @smoke",
      "react16 > should work with multi-root elements (fragments)",
      "react16 > should not crash when there is no match",
      "react16 > should compose",
      "react16 > should query by props combinations",
      "react16 > should exact match by props",
      "react16 > should partially match by props",
      "react16 > should support all string operators",
      "react16 > should support regex",
      "react16 > should support truthy querying",
      "react16 > should support nested react trees",
      "react16 > should work with react memo",
      "react16 > should work with multiroot react",
      "react16 > should work with multiroot react inside shadow DOM",
      "react16 > should work with multiroot react after unmount",
      "react17 > should work with single-root elements @smoke",
      "react17 > should work with multi-root elements (fragments)",
      "react17 > should not crash when there is no match",
      "react17 > should compose",
      "react17 > should query by props combinations",
      "react17 > should exact match by props",
      "react17 > should partially match by props",
      "react17 > should support all string operators",
      "react17 > should support regex",
      "react17 > should support truthy querying",
      "react17 > should support nested react trees",
      "react17 > should work with react memo",
      "react17 > should work with multiroot react",
      "react17 > should work with multiroot react inside shadow DOM",
      "react17 > should work with multiroot react after unmount",
      "react18 > should work with single-root elements @smoke",
      "react18 > should work with multi-root elements (fragments)",
      "react18 > should not crash when there is no match",
      "react18 > should compose",
      "react18 > should query by props combinations",
      "react18 > should exact match by props",
      "react18 > should partially match by props",
      "react18 > should support all string operators",
      "react18 > should support regex",
      "react18 > should support truthy querying",
      "react18 > should support nested react trees",
      "react18 > should work with react memo",
      "react18 > should work with multiroot react",
      "react18 > should work with multiroot react inside shadow DOM",
      "react18 > should work with multiroot react after unmount"
    ]
  },
  "page/selectors-register.spec.ts": {
    "failing": [
      "textContent should be atomic",
      "innerText should be atomic",
      "innerHTML should be atomic",
      "getAttribute should be atomic",
      "isVisible should be atomic",
      "should take java-style string"
    ]
  },
  "page/selectors-role.spec.ts": {
    "failing": [
      "should detect roles",
      "should support selected",
      "should support checked",
      "should support pressed",
      "should support expanded",
      "should support disabled",
      "should inherit disabled from the ancestor",
      "should support disabled fieldset",
      "should support level",
      "should filter hidden, unless explicitly asked for",
      "should support name",
      "errors",
      "hidden with shadow dom slots",
      "should support output accessible name",
      "should not match scope by default"
    ]
  },
  "page/selectors-text.spec.ts": {
    "failing": [
      "should work @smoke",
      "should work with :text",
      "should support empty string",
      "should work across nodes",
      "text-is() should ignore comments",
      "should work with text nodes in quoted mode",
      "should clear caches",
      "should work with :has-text",
      "should work with large DOM",
      "should be case sensitive if quotes are specified",
      "should search for a substring without quotes",
      "should skip head, script and style",
      "should match input[type=button|submit]",
      "should work for open shadow roots",
      "should prioritize light dom over shadow dom in the same parent",
      "should waitForSelector with distributed elements",
      "should match root after >>",
      "should match root after >> with *",
      "should work with leading and trailing spaces",
      "should work with unpaired quotes when not at the start",
      "should work with paired quotes in the middle of selector",
      "hasText and internal:text should match full node text in strict mode"
    ]
  },
  "page/selectors-vue.spec.ts": {
    "failing": [
      "vue2 > should work with single-root elements @smoke",
      "vue2 > should work with multi-root elements (fragments)",
      "vue2 > should not crash when there is no match",
      "vue2 > should compose",
      "vue2 > should query by props combinations",
      "vue2 > should exact match by props",
      "vue2 > should partially match by props",
      "vue2 > should support all string operators",
      "vue2 > should support regex",
      "vue2 > should support truthy querying",
      "vue2 > should support nested vue trees",
      "vue2 > should work with multiroot react",
      "vue2 > should work with multiroot vue inside shadow DOM",
      "vue3 > should work with single-root elements @smoke",
      "vue3 > should work with multi-root elements (fragments)",
      "vue3 > should not crash when there is no match",
      "vue3 > should compose",
      "vue3 > should query by props combinations",
      "vue3 > should exact match by props",
      "vue3 > should partially match by props",
      "vue3 > should support all string operators",
      "vue3 > should support regex",
      "vue3 > should support truthy querying",
      "vue3 > should support nested vue trees",
      "vue3 > should work with multiroot react",
      "vue3 > should work with multiroot vue inside shadow DOM"
    ]
  },
  "page/to-match-aria-snapshot.spec.ts": {
    "failing": [
      "should match",
      "should match in list",
      "should match list with accessible name",
      "should match deep item",
      "should match complex",
      "should match regex",
      "should allow text nodes",
      "details visibility",
      "checked attribute",
      "disabled attribute",
      "expanded attribute",
      "level attribute",
      "pressed attribute",
      "selected attribute",
      "integration test",
      "integration test 2",
      "expected formatter",
      "should unpack escaped names",
      "should report error in YAML",
      "should report error in YAML keys",
      "call log should contain actual snapshot",
      "should parse attributes",
      "should not unshift actual template text",
      "should not match what is not matched",
      "should match url",
      "should detect unexpected children: equal",
      "should detect unexpected children: deep-equal",
      "should allow restoring contain mode inside deep-equal",
      "top-level deep-equal",
      "treat bad regex as a string"
    ]
  },
  "page/wheel.spec.ts": {
    "failing": [
      "should dispatch wheel events @smoke",
      "should dispatch wheel events after popup was opened @smoke",
      "should dispatch wheel event on svg element",
      "should scroll when nobody is listening",
      "should set the modifiers",
      "should scroll horizontally",
      "should work when the event is canceled"
    ]
  },
  "page/workers.spec.ts": {
    "failing": [
      "Page.workers @smoke",
      "should emit created and destroyed events",
      "should report console logs",
      "should not report console logs from workers twice",
      "should have JSHandles for console logs",
      "should evaluate",
      "should report errors",
      "should clear upon navigation",
      "should clear upon cross-process navigation",
      "should attribute network activity for worker inside iframe to the iframe",
      "should report network activity",
      "should report network activity on worker creation",
      "should report worker script as network request",
      "should report worker script as network request after redirect",
      "should dispatch console messages when page has workers",
      "should report and intercept network from nested worker",
      "should support extra http headers",
      "should support offline",
      "should report console event on the worker",
      "should report console event on the worker when not listening on page or context"
    ]
  }
}